<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!-- Constructed with LabVIEW Report Generation -->
<HEAD>
<TITLE></TITLE>
</HEAD>

<BODY>
<h2 id="TypeDef" >TypeDef</h2>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-APRIL_TAG_POSE_ESTIMATOR" >TypeDef-APRIL_TAG_POSE_ESTIMATOR</h3>
<p><IMG SRC="APRIL_TAG_POSE_ESTIMATOR_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Pose estimators for AprilTag tags.<BR>
<BR>
Contains:<BR>
<BR>
  --  tagSize --  double  -- tag size, in meters<BR>
  --  fx  --  double  --  camera horizontal focal length, in pixels<BR>
  --  fy  --  double  --  camera vertical focal length, in pixels<BR>
  --  cx  -- double  --  camera horizontal focal center, in pixels<BR>
  --  cy  --  double  --  camera vertical focal center, in pixels<BR>
</pre></p>
<p><IMG SRC="APRIL_TAG_POSE_ESTIMATOR_frontpanel.png"  ALT="Trajectory_Library.lvlib:APRIL_TAG_POSE_ESTIMATOR.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-ARM_FF" >TypeDef-ARM_FF</h3>
<p><IMG SRC="ARM_FF_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Data cluster for a set of functions. that compute feedforward outputs for a simple arm (modeled as a motor acting against the force of gravity on a beam suspended at an angle. <BR>
<BR>
Units of the gain values will dictate units of the computed feedforward.<BR>
<BR>
Elements"<BR>
   - Ks - The static gain.<BR>
   - Kv - The velocity gain.<BR>
   - Ka - The acceleration gain.<BR>
   - KCos - The gravity gain.<BR>
   </pre></p>
<p><IMG SRC="ARM_FF_frontpanel.png"  ALT="Trajectory_Library.lvlib:ARM_FF.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-AprilTag" >TypeDef-AprilTag</h3>
<p><IMG SRC="AprilTag_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Data cluster to store information for an April Tag vision target.  The stored data includes:<BR>
<BR>
--  ID  -- Integer  --  The April Tag ID value.<BR>
--  Pose3d  --  Pose3d  -- The position of this April Tag.  </pre></p>
<p><IMG SRC="AprilTag_frontpanel.png"  ALT="Trajectory_Library.lvlib:AprilTag.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-AprilTagFieldLayout" >TypeDef-AprilTagFieldLayout</h3>
<p><IMG SRC="AprilTagFieldLayout_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Data cluster and set of funcitons for representing a layout of AprilTags on a field.  (Currently reading the field definition from a file is not yet supported.)<BR>
<BR>
The JSON format contains two top-level objects, "tags" and "field". The "tags" object is a list of all AprilTags contained within a layout. Each AprilTag serializes to a JSON object containing an ID and a Pose3d. The "field" object is a descriptor of the size of the field in meters with "width" and "length" values. This is to account for arbitrary field sizes when transforming the poses.<BR>
<BR>
Pose3ds in the JSON are measured using the normal FRC coordinate system, NWU with the origin at the bottom-right corner of the blue alliance wall. {@link #setOrigin(OriginPosition)} can be used to change the poses returned from AprilTagFieldLayout_getTagPose(int)} to be from the perspective of a specific alliance.<BR>
<BR>
The data cluster contains:<BR>
  -- AprilTagMap --  Map<Integer,APrilTag>  -- A map indexable by April Tag ID to obtain specific AprilTag data clusters.<BR>
  --  Field Length  -- double  -- Field length (meters)<BR>
  --  Field Width  --  double  -- Field width (meters)<BR>
  --  OriginPosition --  enum  -- Origin is red or blue alliance.   (normal origin is blue alliance).<BR>
  --  OriginPose3d  -- Pose3d  -- Position of the origin.<BR>
</pre></p>
<p><IMG SRC="AprilTagFieldLayout_frontpanel.png"  ALT="Trajectory_Library.lvlib:AprilTagFieldLayout.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-AprilTagPoseEstimate" >TypeDef-AprilTagPoseEstimate</h3>
<p><IMG SRC="AprilTagPoseEstimate_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;"> pair of AprilTag pose estimates. <BR>
<BR>
Contains:<BR>
  --  AprilTransform3d_1  -- Transform3d  -- First Transform to AprilTag<BR>
  --  AprilTransform3d_2  -- Transform3d  -- Second Transform to AprilTag<BR>
  --  Error1  -- Double  --  error of first pose<BR>
  --  Error2  --  Double  --  error of second pose</pre></p>
<p><IMG SRC="AprilTagPoseEstimate_frontpanel.png"  ALT="Trajectory_Library.lvlib:AprilTagPoseEstimate.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-BANG_BANG" >TypeDef-BANG_BANG</h3>
<p><IMG SRC="BANG_BANG_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Implements a bang-bang controller, which outputs either 0 or 1 depending on whether the measurement is less than the setpoint. This maximally-aggressive control approach works very well for velocity control of high-inertia mechanisms, and poorly on most other things.  <BR>
 <BR>
Note that this is an *asymmetric* bang-bang controller - it will not exert any control effort in the reverse direction (e.g. it won't try to slow down an over-speeding shooter wheel). This asymmetry is *extremely important.* Bang-bang control is extremely simple, but also potentially hazardous. Always ensure that your motor controllers are set to "coast" before attempting to<BR>
control them with a bang-bang controller.<BR>
<BR>
Data stored in this cluster<BR>
   -  Tolerance<BR>
   -  Setpoint<BR>
   - Measurment<BR>
</pre></p>
<p><IMG SRC="BANG_BANG_frontpanel.png"  ALT="Trajectory_Library.lvlib:BANG_BANG.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-BiCon_Matrix_FUNC_TYPE" >TypeDef-BiCon_Matrix_FUNC_TYPE</h3>
<p><IMG SRC="BiCon_Matrix_FUNC_TYPE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;"></pre></p>
<p><IMG SRC="BiCon_Matrix_FUNC_TYPE_frontpanel.png"  ALT="Trajectory_Library.lvlib:BiCon_Matrix_FUNC_TYPE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-CALLBACK_FUNC_TYPE" >TypeDef-CALLBACK_FUNC_TYPE</h3>
<p><IMG SRC="CALLBACK_FUNC_TYPE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This strictly typed function reference it used by various functions to declare the call-backs needed for operation.  It has the following parameters:<BR>
<BR>
Inputs:<BR>
   - ExtraData  --  Variant containing extra data used by this function<BR>
   - Mat X  --  Input Matrix<BR>
   - Mat U  --  Input Matrix<BR>
   <BR>
Outputs:<BR>
   - Mat Output  --  Output Matrix<BR>
   - Error  -- Boolean, If TRUE indicates an error has occured.</pre></p>
<p><IMG SRC="CALLBACK_FUNC_TYPE_frontpanel.png"  ALT="Trajectory_Library.lvlib:CALLBACK_FUNC_TYPE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-CHASSIS_SPEEDS" >TypeDef-CHASSIS_SPEEDS</h3>
<p><IMG SRC="CHASSIS_SPEEDS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents the speed of a robot chassis. Although this struct contains similar members compared to a Twist2d, they do NOT represent the same thing.  Whereas a Twist2d represents a change in pose w.r.t to the robot frame of reference, this ChassisSpeeds struct represents a velocity w.r.t to the robot frame of<BR>
reference.<BR>
<BR>
A strictly non-holonomic drivetrain, such as a differential drive, should never have a dy component because it can never move sideways. Holonomic drivetrains such as swerve and mecanum will often have all three components.<BR>
<BR>
</pre></p>
<p><IMG SRC="CHASSIS_SPEEDS_frontpanel.png"  ALT="Trajectory_Library.lvlib:CHASSIS_SPEEDS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-CONSTRAINED_STATE" >TypeDef-CONSTRAINED_STATE</h3>
<p><IMG SRC="CONSTRAINED_STATE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Internal data structure used by TrajectoryParam_timeParam.</pre></p>
<p><IMG SRC="CONSTRAINED_STATE_frontpanel.png"  ALT="Trajectory_Library.lvlib:CONSTRAINED_STATE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-COORDINATE_AXIS" >TypeDef-COORDINATE_AXIS</h3>
<p><IMG SRC="COORDINATE_AXIS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A data cluster representing a coordinate system axis within the NWU coordinate system.<BR>
</pre></p>
<p><IMG SRC="COORDINATE_AXIS_frontpanel.png"  ALT="Trajectory_Library.lvlib:COORDINATE_AXIS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-COORDINATE_SYSTEM" >TypeDef-COORDINATE_SYSTEM</h3>
<p><IMG SRC="COORDINATE_SYSTEM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A helper data cluster that converts Pose3d objects between different standard coordinate frames. <BR>
<BR>
Contains:<BR>
  -- Rotation 3d  --  Rotation from this coordinate system to NWU coordinate system<BR>
</pre></p>
<p><IMG SRC="COORDINATE_SYSTEM_frontpanel.png"  ALT="Trajectory_Library.lvlib:COORDINATE_SYSTEM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DCMOTOR" >TypeDef-DCMOTOR</h3>
<p><IMG SRC="DCMOTOR_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Holds the constants for a DC motor.<BR>
<BR>
Data<BR>
   -  NominalVoltage_Volts  --  Voltage at which the motor constants were measured. (Volts)<BR>
   -  StallTorque_NewtonMeters  --  <BR>
   -  StallCurrent_Amps  --  Current draw when stalled.<BR>
   -  FreeCurrent_Amps  --  Current draw under no load.<BR>
   -  FreeSpeed_RadPerSec  --  Angular velocity under no load.<BR>
   -  R_Ohms  --  Winding resistance (Ohms)<BR>
   -  Kv_RadPerSecPerVolt  --  Motor speed constant.  Note that some documentation inverts this value.<BR>
   -  Kt_NewtonMeterPerAmp  --  Motor torque constant.<BR>
<BR>
The following pieces of data may not exit for all motors.<BR>
   -  L_H  --  Winding inductance (Henrys)  --  <BR>
   - Jr_KgM2  --  Motor moment of inertia  --  <BR>
</pre></p>
<p><IMG SRC="DCMOTOR_frontpanel.png"  ALT="Trajectory_Library.lvlib:DCMOTOR.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DCMOTOR_SIM" >TypeDef-DCMOTOR_SIM</h3>
<p><IMG SRC="DCMOTOR_SIM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a simulated DC Motor mechanism.<BR>
<BR>
Cluster contains:<BR>
   - Gearbox  -- DCMotor cluster  for the flywheel.<BR>
   - Gearing  --  Double, gearing between the motors and the output.<BR>
   - LinearSystemSim  -- Cluster for the simulation.<BR>
<BR>
</pre></p>
<p><IMG SRC="DCMOTOR_SIM_frontpanel.png"  ALT="Trajectory_Library.lvlib:DCMOTOR_SIM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DCMOTOR_SIM_SIMULATION_PARAMS" >TypeDef-DCMOTOR_SIM_SIMULATION_PARAMS</h3>
<p><IMG SRC="DCMOTOR_SIM_SIMULATION_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster containing packed simulation parameters used by the DC Motor Simulation Execute routine.<BR>
<BR>
Contains:<BR>
  -  Pos Sim Std Dev  --  double  -- Standard deviation for the motor position (Rotations  Default: 2)<BR>
  -  Vel Sim Std Dev  --  double  --  Standard deviation for the motor velocity (RPM, Default: 2)<BR>
</pre></p>
<p><IMG SRC="DCMOTOR_SIM_SIMULATION_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:DCMOTOR_SIM_SIMULATION_PARAMS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DEBOUNCER" >TypeDef-DEBOUNCER</h3>
<p><IMG SRC="DEBOUNCER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A simple debounce filter for boolean streams. Requires that the boolean change value from baseline for a specified period of time before the filtered value changes.<BR>
<BR>
This cluster contains:<BR>
   - DebounceTimeSeconds  --  Double<BR>
   - PrevTimeSeconds  --  Double<BR>
   - DebounceType  --  Debouce Type enum<BR>
   - Baseline  --  Boolean<BR>
</pre></p>
<p><IMG SRC="DEBOUNCER_frontpanel.png"  ALT="Trajectory_Library.lvlib:DEBOUNCER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_ACCEL_LIMIT" >TypeDef-DIFF_DRIVE_ACCEL_LIMIT</h3>
<p><IMG SRC="DIFF_DRIVE_ACCEL_LIMIT_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Filters the provided voltages to limit a differential drive's linear and angular acceleration.<BR>
<BR>
The differential drive model can be created via the functions in LinearSystemId.<BR>
 <BR>
The data values are:<BR>
   - System  --  Linear System<BR>
   - trackWidth -- trackwidth (meters) <BR>
   - minLinearAccel  --  (meters/sec*2)<BR>
   - maxLinearAccel  --  (meters/sec*2)<BR>
   - maxAngularAccel   --  (radians/sec^2)<BR>
</pre></p>
<p><IMG SRC="DIFF_DRIVE_ACCEL_LIMIT_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_ACCEL_LIMIT.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_KINEMATICS" >TypeDef-DIFF_DRIVE_KINEMATICS</h3>
<p><IMG SRC="DIFF_DRIVE_KINEMATICS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Helper class that converts a chassis velocity (dx and dtheta components) to left and right wheel velocities for a differential drive.<BR>
<BR>
Inverse kinematics converts a desired chassis speed into left and right velocity components whereas forward kinematics converts left and right component velocities into a linear and angular chassis speed.<BR>
</pre></p>
<p><IMG SRC="DIFF_DRIVE_KINEMATICS_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_KINEMATICS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_ODOM2" >TypeDef-DIFF_DRIVE_ODOM2</h3>
<p><IMG SRC="DIFF_DRIVE_ODOM2_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster and subVI for differential drive odometry. Odometry allows you to track the robot's position on the field over the course of a match using readings from 2 encoders and a gyroscope.<BR>
 <BR>
Teams can use odometry during the autonomous period for complex tasks like path following.  Furthermore, odometry can be used for latency compensation when using computer-vision systems.<BR>
<BR>
The gyro and encoders do NOT have to be reset before using this.<BR>
<BR>
This cluster contains:<BR>
  --  M_Pose_Meters  --  Pose2d  -- Current robot position  (meters)<BR>
  --  M_GyroOffset  --  Rotation2d  -- Initial gyro value<BR>
  --  M_PrevLeftDist_M  -- Double  -- Previous reading of left wheel encoder distance (meters) <BR>
  --  M_PrevRightDist_M  -- Double  -- Previous reading of right wheel encoder distance (meters) <BR>
  --  M_InitLeftDist_M  -- Double  -- Initial reading of left wheel encoder distance (meters) <BR>
  --  M_InitRightDist_M  -- Double  -- Initial reading of right wheel encoder distance (meters) <BR>
</pre></p>
<p><IMG SRC="DIFF_DRIVE_ODOM2_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_ODOM2.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_POSE_EST" >TypeDef-DIFF_DRIVE_POSE_EST</h3>
<p><IMG SRC="DIFF_DRIVE_POSE_EST_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This set of functions is deprecated.   Suggest using the new Diff Drive Pose Est 2 instead.<BR>
<BR>
This set of subVI wraps an UnscentedKalmanFilter to fuse latency-compensated vision measurements with differential drive encoder measurements. It will correct for noisy vision measurements and encoder drift. It is intended to be an easy drop-in for DifferentialDriveOdometry; in fact, if you never call DifferentialDrivePoseEstimator_addVisionMeasurement and only call DifferentialDrivePoseEstimator_update then this will behave exactly the same as DifferentialDriveOdometry.<BR>
 <BR>
DifferentialDrivePoseEstimator_update should be called every robot loop (if your robot loops are faster than the default then you should change specify the update time when creating this data cluster. DifferentialDrivePoseEstimator_addVisionMeasurement can be called as infrequently as you want; if you never call it then this class will behave exactly like regular encoder odometry.<BR>
<BR>
To promote stability of the pose estimate and make it robust to bad vision data, we recommend only adding vision measurements that are already within one meter or so of the current pose estimate.<BR>
<BR>
Our state-space system is:<BR>
<BR>
    x = [[x, y, theta, dist_l, dist_r]]?  in the field coordinate system (dist_* are wheel distances.)<BR>
 <BR>
    u = [[vx, vy, omega]]?  (robot-relative velocities) -- NB: using velocities make things considerably <BR>
                           easier, because it means that teams don't have to worry about getting an accurate <BR>
                           model. Basically, we suspect that it's easier for teams to get good encoder data than <BR>
                           it is for them to perform system identification well enough to get a good model.<BR>
 <BR>
    y = [[x, y, theta]]?  from vision, or y = [[dist_l, dist_r, theta]]  from encoders and gyro.<BR>
 <BR>
</pre></p>
<p><IMG SRC="DIFF_DRIVE_POSE_EST_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_POSE_EST.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_POSE_EST2" >TypeDef-DIFF_DRIVE_POSE_EST2</h3>
<p><IMG SRC="DIFF_DRIVE_POSE_EST2_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This set of functions wraps Differential Drive Odometry to fuse latency-compensated vision measurements with differential drive encoder measurements. It is intended to be a drop-in replacement for DiffDrvOdom2; in fact, if you never call DiffDrvPoseEst2_AddVisionMeasurement and only call  DiffDrvPoseEst2_Update then this will behave exactly the same as DiffDrvOdom2.<BR>
 <BR>
DiffDrvPoseEst2_Update should be called every robot loop.<BR>
 <BR>
DiffDrvPoseEst2_AddVisionMeasurement can be called as infrequently as you want.  If you never call it then this set of VI will behave exactly like regular encoder odometry.<BR>
<BR>
This data cluster contains:<BR>
  --  Diff_Drive_Kinematics  -- Diff_Drive_Kinematics  -- Kinematics data cluster that defines this drive.<BR>
  --  Diff_Pose_Odom2  -- Diff_Drive__Odom2  --  Odometry data cluster for this drive.<BR>
  --  M_Q -- <3,1> Matrix -- Matrix that holds standard deviations for the robot pose X, Y, theta (meters, meters, radians)<BR>
  --  M_Vision_K  --  <3,3> Matrix  -- Matrix that holds the gain matrix for closed loop continuous Kalman filter.<BR>
  --  Pose_Buffer -- TimeInterpBufferVariant  -- Holds last 1.5 seconds of position measurements.  <BR>
<BR>
</pre></p>
<p><IMG SRC="DIFF_DRIVE_POSE_EST2_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_POSE_EST2.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_POSE_EST2_CONFIG" >TypeDef-DIFF_DRIVE_POSE_EST2_CONFIG</h3>
<p><IMG SRC="DIFF_DRIVE_POSE_EST2_CONFIG_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Clustere containing configuration data required by the DiffDrivePoseEst2_Execute function.  <BR>
<BR>
Contains:<BR>
  -  TrackWidth_Meters  -- double  --  Effective tract width (meters)<BR>
  -  Odom X Std Dev M  -- double  --  Odometry X position standard deviation (Default: 0.02)  (meters)<BR>
  -  Odom Y Std Dev M  -- double  --  Odometry Y position standard deviation (Default: 0.02)  (meters)<BR>
  -  Odom Heading Std Dev M  -- double  --  Odometry Heading (gyro) position standard deviation (Default: 0.01)  (radians)<BR>
  -  Vision X Std Dev M  -- double  --  Vision X position standard deviation (Default: 0.1)  (meters)<BR>
  -  Vision Y Std Dev M  -- double  --  Vision Y position standard deviation (Default: 0.1)  (meters)<BR>
  -  Vision Heading Std Dev M  -- double  --  Vision Heading (gyro) position standard deviation (Default: 0.05)  (radians)<BR>
<BR>
</pre></p>
<p><IMG SRC="DIFF_DRIVE_POSE_EST2_CONFIG_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_POSE_EST2_CONFIG.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_POSE_EST2_INTERP_RECORD" >TypeDef-DIFF_DRIVE_POSE_EST2_INTERP_RECORD</h3>
<p><IMG SRC="DIFF_DRIVE_POSE_EST2_INTERP_RECORD_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Differential Drive Pose Estimate 2 -- Interporatable Record. <BR>
</pre></p>
<p><IMG SRC="DIFF_DRIVE_POSE_EST2_INTERP_RECORD_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_POSE_EST2_INTERP_RECORD.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_SIM_MODEL_PARAMS" >TypeDef-DIFF_DRIVE_SIM_MODEL_PARAMS</h3>
<p><IMG SRC="DIFF_DRIVE_SIM_MODEL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;"></pre></p>
<p><IMG SRC="DIFF_DRIVE_SIM_MODEL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_SIM_MODEL_PARAMS.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_SIM_SIMULATION_PARAMS" >TypeDef-DIFF_DRIVE_SIM_SIMULATION_PARAMS</h3>
<p><IMG SRC="DIFF_DRIVE_SIM_SIMULATION_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;"></pre></p>
<p><IMG SRC="DIFF_DRIVE_SIM_SIMULATION_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_SIM_SIMULATION_PARAMS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DIFF_DRIVE_TRAIN_SIM" >TypeDef-DIFF_DRIVE_TRAIN_SIM</h3>
<p><IMG SRC="DIFF_DRIVE_TRAIN_SIM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This data cluster holds the values for the Differential Drive Train functions that  simulate the state of the drivetrain. In simulationPeriodic, users should first set inputs from motors with setInputs(double, double)}, call update(double)} to update the simulation, and set estimated encoder and gyro positions, as well as estimated odometry pose. <BR>
 <BR>
Our state-space system is:<BR>
 <BR>
      x = [[x, y, theta, vel_l, vel_r, dist_l, dist_r]] <BR>
<BR>
      in the field coordinate system (dist_* are wheel distances.)<BR>
 <BR>
      u = [[voltage_l, voltage_r]]? <BR>
<BR>
      This is typically the control input of the last timestep from a LTVDiffDriveController.<BR>
 <BR>
      y = x<BR>
 <BR>
The data values are:<BR>
   - Plant  --  Linear System<BR>
   - X  --  <BR>
   - Y  --  <BR>
   - U  --  <BR>
   - MeasureStdDev  --  <BR>
   - Motor  --  DC motor cooeficients.<BR>
   - OriginalGearing  --  <BR>
   - CurrentGearing  --  <BR>
   - WheelRadius  --  (Meters)<BR>
   - RB  -- Radius of the robot base ( TrackWidth / 2 )  (Meters)</pre></p>
<p><IMG SRC="DIFF_DRIVE_TRAIN_SIM_frontpanel.png"  ALT="Trajectory_Library.lvlib:DIFF_DRIVE_TRAIN_SIM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DISPLAY_WAYPOINT" >TypeDef-DISPLAY_WAYPOINT</h3>
<p><IMG SRC="DISPLAY_WAYPOINT_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Defines a trajectory waypoint.  This is a convienence TypeDef for use with utility programs.  The actual trajectory creation subVI take a number of different data types, which can all be derived from this way point.  In some cases, such as cubic spline creation, the angle data for the interior waypoints is ignored.  The cubic routine calculates optimum angles.</pre></p>
<p><IMG SRC="DISPLAY_WAYPOINT_frontpanel.png"  ALT="Trajectory_Library.lvlib:DISPLAY_WAYPOINT.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-DISPLAY_WEIGHTED_WAYPOINT" >TypeDef-DISPLAY_WEIGHTED_WAYPOINT</h3>
<p><IMG SRC="DISPLAY_WEIGHTED_WAYPOINT_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Defines a trajectory waypoint.  This is a convienence TypeDef for use to display weighted waypoint.  The actual trajectory creation subVI take a number of different data types, which can all be derived from this way point.  In some cases, such as cubic spline creation, the angle data for the interior waypoints is ignored.  The cubic routine calculates optimum angles.</pre></p>
<p><IMG SRC="DISPLAY_WEIGHTED_WAYPOINT_frontpanel.png"  ALT="Trajectory_Library.lvlib:DISPLAY_WEIGHTED_WAYPOINT.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-ELEVATOR_SIM" >TypeDef-ELEVATOR_SIM</h3>
<p><IMG SRC="ELEVATOR_SIM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a simulated elevator mechanism.<BR>
<BR>
Cluster contains:<BR>
   - Gearbox  -- DCMotor cluster  for the elevator.<BR>
   - Gearing  --  Double, gearing between the motors and the output.<BR>
   - DrumRadius  --  Double, the radius of the drum that the elevator spool is wrapped around.  (Meters)<BR>
   - MinHeight  -- Double, the min allowable height for the elevator. (Meters)<BR>
   - MaxHeight  --  Double, the max allowable height for the elevator. (Meters)<BR>
   - CarriageMass  -- Double, the mass of the elevator carriage (Kilograms)<BR>
   - LinearSystemSim  -- Cluster for the simulated system.<BR>
</pre></p>
<p><IMG SRC="ELEVATOR_SIM_frontpanel.png"  ALT="Trajectory_Library.lvlib:ELEVATOR_SIM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-ELEVATOR_SIM_SIMULATION_PARAMS" >TypeDef-ELEVATOR_SIM_SIMULATION_PARAMS</h3>
<p><IMG SRC="ELEVATOR_SIM_SIMULATION_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains simulation parameters used by the Elevator Simulation Execute routine.<BR>
<BR>
Inputs:<BR>
  -  Min Height  --  double  --  Minimum physical elevator height (meters)<BR>
  -  Max Height  --  double  --  Maximum physical elevator height (meters)<BR>
  -  Pos Sim Std Dev  --  double  -- Standard deviation for the motor position (meters  Default: 0.09)<BR>
  - SimulateGravity  --  boolean  -- Simulate gravity (Default: True)<BR>
<BR>
</pre></p>
<p><IMG SRC="ELEVATOR_SIM_SIMULATION_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:ELEVATOR_SIM_SIMULATION_PARAMS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-ELEV_FF" >TypeDef-ELEV_FF</h3>
<p><IMG SRC="ELEV_FF_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A helper set of functions that computes feedforward outputs for a simple elevator (modeled as a motor acting against the force of gravity).<BR>
<BR>
Data cluster contents:<BR>
   - Ks  --  The static gain<BR>
   - Kv  --  The velocity gain<BR>
   - Ka  --  The acceration gain<BR>
   - Kg  -- The gravity gain<BR>
</pre></p>
<p><IMG SRC="ELEV_FF_frontpanel.png"  ALT="Trajectory_Library.lvlib:ELEV_FF.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-EXTENDED_KALMAN_CORRECT_FUNC_GROUP" >TypeDef-EXTENDED_KALMAN_CORRECT_FUNC_GROUP</h3>
<p><IMG SRC="EXTENDED_KALMAN_CORRECT_FUNC_GROUP_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This data cluster holds data for the call back functions used by the Extended Kalman FIlter.<BR>
<BR>
The cluster contains:<BR>
   - F_Func  --  Strictly typed function referenced.<BR>
   - F_FuncExtra  --  Variant containing extra data, if any, used by the callback function.<BR>
   - H_Func  --  Strictly typed function referenced.<BR>
   - H_FuncExtra  --  Variant containing extra data, if any, used by the callback function.<BR>
</pre></p>
<p><IMG SRC="EXTENDED_KALMAN_CORRECT_FUNC_GROUP_frontpanel.png"  ALT="Trajectory_Library.lvlib:EXTENDED_KALMAN_CORRECT_FUNC_GROUP.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-EXTENDED_KALMAN_FILTER" >TypeDef-EXTENDED_KALMAN_FILTER</h3>
<p><IMG SRC="EXTENDED_KALMAN_FILTER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">THIS IS A WORK IN PROGRESS.  PROBABLY NOT FIT FOR USE YET...<BR>
<BR>
Kalman filters combine predictions from a model and measurements to give an estimate of the true system state. This is useful because many states cannot be measured directly as a result of sensor noise, or because the state is "hidden".<BR>
 <BR>
The Extended Kalman filter is just like the KalmanFilter Kalman filter, but we make a linear approximation of nonlinear dynamics and/or nonlinear measurement models. This means that the EKF works with nonlinear systems.<BR>
</pre></p>
<p><IMG SRC="EXTENDED_KALMAN_FILTER_frontpanel.png"  ALT="Trajectory_Library.lvlib:EXTENDED_KALMAN_FILTER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-FLYWHEEL_SIM" >TypeDef-FLYWHEEL_SIM</h3>
<p><IMG SRC="FLYWHEEL_SIM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a simulated flywheel mechanism.<BR>
<BR>
Cluster contains:<BR>
   - Gearbox  -- DCMotor cluster  for the flywheel.<BR>
   - Gearing  --  Double, gearing between the motors and the output.<BR>
   - LinearSystemSim  -- Cluster for the simulation.<BR>
<BR>
</pre></p>
<p><IMG SRC="FLYWHEEL_SIM_frontpanel.png"  ALT="Trajectory_Library.lvlib:FLYWHEEL_SIM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-FLYWHEEL_SIM_SIMULATION_PARAMS" >TypeDef-FLYWHEEL_SIM_SIMULATION_PARAMS</h3>
<p><IMG SRC="FLYWHEEL_SIM_SIMULATION_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster containing simulation parameters used by the Flywheel Simulation Execute routine.<BR>
<BR>
Contains:<BR>
  -  Vel Sim Std Dev  --  double  -- Standard deviation for the flywheel velocity (rad/sec  Default: 1)<BR>
<BR>
</pre></p>
<p><IMG SRC="FLYWHEEL_SIM_SIMULATION_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:FLYWHEEL_SIM_SIMULATION_PARAMS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-FUNCTION_GENERATOR" >TypeDef-FUNCTION_GENERATOR</h3>
<p><IMG SRC="FUNCTION_GENERATOR_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Function Generators (Interpolating Tree Maps) are used to get values at points that are not defined by making a guess from points that are defined. This uses linear interpolation.<BR>
<BR>
The data cluster contains:<BR>
  --  Table Xs  --  Array of X values<BR>
  --  Table Ys  --  Array of Y values cooresponding the the X values.<BR>
   --  MinX  -- Smallest X value<BR>
   --  MaxX  -- Largest X value.  <BR>
   --  ItemCount  -- Number of items in the X and Y arrays.<BR>
</pre></p>
<p><IMG SRC="FUNCTION_GENERATOR_frontpanel.png"  ALT="Trajectory_Library.lvlib:FUNCTION_GENERATOR.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-FUNCTION_GENERATOR_MATRIX" >TypeDef-FUNCTION_GENERATOR_MATRIX</h3>
<p><IMG SRC="FUNCTION_GENERATOR_MATRIX_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Function Generator data cluster</pre></p>
<p><IMG SRC="FUNCTION_GENERATOR_MATRIX_frontpanel.png"  ALT="Trajectory_Library.lvlib:FUNCTION_GENERATOR_MATRIX.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-HOLONOMIC_DRV_CTRL" >TypeDef-HOLONOMIC_DRV_CTRL</h3>
<p><IMG SRC="HOLONOMIC_DRV_CTRL_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This holonomic drive controller can be used to follow trajectories using a holonomic drive train (i.e. swerve or mecanum). Holonomic trajectory following is a much simpler problem to solve compared to skid-steer style drivetrains because it is possible to individually control forward, sideways, and angular velocity.<BR>
<BR>
The holonomic drive controller takes in one PID controller for each direction, forward and sideways, and one profiled PID controller for the angular direction. Because the heading dynamics are decoupled from translations, users can specify a custom heading that the drivetrain should point toward. This heading reference is profiled for smoothness.<BR>
<BR>
The cluster contains:<BR>
   - Enabled  --  Boolean, indicating the controller is enabled.<BR>
   - FirstRun  --  Boolean, indicating the controller is running its first loop<BR>
   - PoseTolerance  --  Pose indicating allowable error for calcuating At Reference.<BR>
   - RotationError  --  Rotation containing the current rotation error<BR>
   - PoseError  --  Pose containing the current position error<BR>
   - PID_xCtrl  -- PID to control the X position<BR>
   - PID_yCtrl  --  PID to control the Y position<BR>
   - PROF_PID_ThetaCtrl  -- Profiled PID to control the rotation.<BR>
</pre></p>
<p><IMG SRC="HOLONOMIC_DRV_CTRL_frontpanel.png"  ALT="Trajectory_Library.lvlib:HOLONOMIC_DRV_CTRL.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-IMPLICIT_MODEL_FOLLOWER" >TypeDef-IMPLICIT_MODEL_FOLLOWER</h3>
<p><IMG SRC="IMPLICIT_MODEL_FOLLOWER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Contains the controller coefficients and logic for an implicit model follower.<BR>
<BR>
Implicit model following lets us design a feedback controller that erases the dynamics of our system and makes it behave like some other system. This can be used to make a drivetrain more controllable during teleop driving by making it behave like a slower or more benign drivetrain.<BR>
<BR>
The data cluster contains:<BR>
<BR>
   - m_A  --  State space conversion gain<BR>
   - m_B  -- Input space conversion gain<BR>
   - m_U -- Computed controller output<BR>
   - states<BR>
   - inputs<BR>
<BR>
</pre></p>
<p><IMG SRC="IMPLICIT_MODEL_FOLLOWER_frontpanel.png"  ALT="Trajectory_Library.lvlib:IMPLICIT_MODEL_FOLLOWER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-KALMAN_FILTER" >TypeDef-KALMAN_FILTER</h3>
<p><IMG SRC="KALMAN_FILTER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A Kalman filter combines predictions from a model and measurements to give an estimate of the true system state. This is useful because many states cannot be measured directly as a result of sensor noise, or because the state is "hidden".<BR>
 <BR>
Kalman filters use a K gain matrix to determine whether to trust the model or measurements more. Kalman filter theory uses statistics to compute an optimal K gain which minimizes the sum of squares error in the state estimate. This K gain is used to correct the state estimate by some amount of the difference between the actual measurements and the measurements predicted by the model.<BR>
 <BR>
For more on the underlying math, read https://file.tavsys.net/control/controls-engineering-in-frc.pdf chapter 9 "Stochastic control theory".<BR>
<BR>
The cluster contains:<BR>
   - m_Plant  --  Linear System data cluster<BR>
   - m_K  --  Steady state kalman gain<BR>
   - m_xHat  --  State estimate<BR>
   - States  --  Number of states<BR>
   - Outputs  --  Number of outputs<BR>
<BR>
<BR>
</pre></p>
<p><IMG SRC="KALMAN_FILTER_frontpanel.png"  ALT="Trajectory_Library.lvlib:KALMAN_FILTER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-KALMAN_FILTER_LATENCY_COMP" >TypeDef-KALMAN_FILTER_LATENCY_COMP</h3>
<p><IMG SRC="KALMAN_FILTER_LATENCY_COMP_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Data cluster holding past Observer snapshots that can be used to compensate for time latency.<BR>
<BR>
The cluster contains:<BR>
   - PastObserverSnapshots  --  An array of Observer_Snap_List_Item containing:<BR>
        - TimeStamp  --  Time stamp of snapshot<BR>
        - ObserverSnapShot  --  System state at time of snapshot.  <BR>
</pre></p>
<p><IMG SRC="KALMAN_FILTER_LATENCY_COMP_frontpanel.png"  ALT="Trajectory_Library.lvlib:KALMAN_FILTER_LATENCY_COMP.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-KALMAN_FILTER_LATENCY_COMP_FUNC_GROUP" >TypeDef-KALMAN_FILTER_LATENCY_COMP_FUNC_GROUP</h3>
<p><IMG SRC="KALMAN_FILTER_LATENCY_COMP_FUNC_GROUP_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This data cluster holds data for the call back functions used by the Kalman FIlter Latency Compensator.<BR>
<BR>
The cluster contains:<BR>
   - F_Func  --  Strictly typed function referenced.<BR>
   - F_FuncExtra  --  Variant containing extra data, if any, used by the callback function.<BR>
   - H_Func  --  Strictly typed function referenced.<BR>
   - H_FuncExtra  --  Variant containing extra data, if any, used by the callback function.<BR>
   - VisionCorrect_Func  --  Strictly typed function referenced.<BR>
   - VIsionCorrectExtra  --  Variant containing extra data, if any, used by the callback function.</pre></p>
<p><IMG SRC="KALMAN_FILTER_LATENCY_COMP_FUNC_GROUP_frontpanel.png"  ALT="Trajectory_Library.lvlib:KALMAN_FILTER_LATENCY_COMP_FUNC_GROUP.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_FILTER" >TypeDef-LINEAR_FILTER</h3>
<p><IMG SRC="LINEAR_FILTER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This cluster stores the data for a set of Vis that implement a linear, digital filter. All types of FIR and IIR filters are supported.  A set of VIs are provided to create commonly used types of filters.<BR>
 <BR>
Filters are of the form: <BR>
	y[n] = (b0*x[n] + b1*x[n-1] + ... + bP*x[n-P]) - (a0*y[n-1] + a2*y[n-2] + ... + aQ*y[n-Q])<BR>
 <BR>
Where: <BR>
   - y[n] is the output at time "n" <BR>
   - x[n] is the input at time "n" <BR>
   - y[n-1] is the output from the LAST time step ("n-1") <BR>
   - x[n-1] is the input from the LAST time step ("n-1") <BR>
   - b0...bP are the "feedforward" (FIR) gains <BR>
   - a0...aQ are the "feedback" (IIR) gains <BR>
<BR>
IMPORTANT! Note the "-" sign in front of the feedback term! This is a common convention in signal processing.<BR>
 <BR>
What can linear filters do? Basically, they can filter, or diminish, the effects of undesirable input frequencies. High frequencies, or rapid changes, can be indicative of sensor noise or be otherwise undesirable. A "low pass" filter smooths out the signal, reducing the impact of these high frequency components.  Likewise, a "high pass" filter gets rid of slow-moving signal components, letting you detect large changes more easily.<BR>
 <BR>
Example FRC applications of filters: <BR>
  - Getting rid of noise from an analog sensor input (note: the roboRIO's FPGA can do this faster in hardware)<BR>
  - Smoothing out joystick input to prevent the wheels from slipping or the robot from tipping<BR>
  - Smoothing motor commands so that unnecessary strain isn't put on electrical or mechanical components<BR>
  - If you use clever gains, you can make a PID controller out of this class! (Use the PID set of VI’s instead...)<BR>
 <BR>
For more on filters, we highly recommend the following articles:<BR>
	https://en.wikipedia.org/wiki/Linear_filter<BR>
	https://en.wikipedia.org/wiki/Iir_filter<BR>
	https://en.wikipedia.org/wiki/Fir_filter<BR>
 <BR>
Note 1: calculate() should be called by the user on a known, regular period. You can use code in a periodic function.<BR>
 <BR>
Note 2: For ALL filters, gains are necessarily a function of frequency. If you make a filter that works well for you at, say, 100Hz, (executing every 10 milliseconds ), you will most definitely need to adjust the gains if you then want to run it at 200Hz, (executing every 5 milliseconds)! Combining this with Note 1, the impetus is on YOU as a developer to make sure calculate() gets called at the desired, constant frequency!<BR>
<BR>
<BR>
Elements:<BR>
   - InputGains - Array of “feedforward” or FIR gain factors (bx)<BR>
   - OutputGains - Array of “feedback” or IIR gain factors  (ax)<BR>
   - Inputs - Array of the last n saved inputs<BR>
   - Outputs - Array of the last n saved outputs<BR>
   -  InGainCount - Number of input gain terms<BR>
   -  OutGainCount - number of output gain terms</pre></p>
<p><IMG SRC="LINEAR_FILTER_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_FILTER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_PLANT_INV_FF" >TypeDef-LINEAR_PLANT_INV_FF</h3>
<p><IMG SRC="LINEAR_PLANT_INV_FF_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A plant inversion model-based feedforward from a LinearSystem<BR>
<BR>
The feedforward is calculated as <BR>
      u_ff = B" (r_k+1 - A r_k) <BR>
,<BR>
      where  B"  is the pseudoinverse of B.<BR>
 <BR>
This cluster contains:<BR>
   - m_r  --  The current reference state   <BR>
   - m_uff  --  The computed feedforward.<BR>
   - m_B  --  Discrete input matrix of the plant being controlled.<BR>
   - m_A  --  Discrete system matrix of the plant being controlled<BR>
   - States  --  Number of states<BR>
   - Inputs  --  Number of inputs</pre></p>
<p><IMG SRC="LINEAR_PLANT_INV_FF_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_PLANT_INV_FF.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_QUADRATIC_REGULATOR" >TypeDef-LINEAR_QUADRATIC_REGULATOR</h3>
<p><IMG SRC="LINEAR_QUADRATIC_REGULATOR_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Contains the controller coefficients and logic for a linear-quadratic regulator (LQR). LQRs use the control law u = K(r - x).<BR>
 <BR>
This cluster contains:<BR>
   - m_r  --  The current reference state.<BR>
   - m_u  --  The computed and capped controller output. <BR>
   -  m_K  --  Controller gain.<BR>
   - States  --  Number of states<BR>
   - Inputs  --  Number of inputs.</pre></p>
<p><IMG SRC="LINEAR_QUADRATIC_REGULATOR_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_QUADRATIC_REGULATOR.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM" >TypeDef-LINEAR_SYSTEM</h3>
<p><IMG SRC="LINEAR_SYSTEM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Holds the data for a linear system.  The data cluster contains:<BR>
<BR>
   - m_A  --  Continuous system matrix.<BR>
   - m_B  --  Continuous input matrix.<BR>
   - m_C  --  Output matrix.<BR>
   - m_D  --  Feedthrough matrix.<BR>
<BR>
</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_ID_DCMOTOR_MODEL" >TypeDef-LINEAR_SYSTEM_ID_DCMOTOR_MODEL</h3>
<p><IMG SRC="LINEAR_SYSTEM_ID_DCMOTOR_MODEL_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains model parameters used to create a DC Motor Linear System.<BR>
<BR>
Contains:<BR>
  -  DCMOTOR_TYPE  --  enum  --  Model of motor being used.<BR>
  -  Num Numtors  --  integer  --  Number of motors used.<BR>
  -  Gearing  -- double  -- Gear ratio.    (Input speed / Output Speed )<BR>
  -  MOI  --  double  -- Moment of inertia  - kg m^2<BR>
</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_ID_DCMOTOR_MODEL_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_ID_DCMOTOR_MODEL.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_ID_ELEVATOR_MODEL" >TypeDef-LINEAR_SYSTEM_ID_ELEVATOR_MODEL</h3>
<p><IMG SRC="LINEAR_SYSTEM_ID_ELEVATOR_MODEL_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;"></pre></p>
<p><IMG SRC="LINEAR_SYSTEM_ID_ELEVATOR_MODEL_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_ID_ELEVATOR_MODEL.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_ID_FLYWHEEL_MODEL" >TypeDef-LINEAR_SYSTEM_ID_FLYWHEEL_MODEL</h3>
<p><IMG SRC="LINEAR_SYSTEM_ID_FLYWHEEL_MODEL_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;"></pre></p>
<p><IMG SRC="LINEAR_SYSTEM_ID_FLYWHEEL_MODEL_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_ID_FLYWHEEL_MODEL.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_ID_SINGLE_JOINT_ARM_MODEL" >TypeDef-LINEAR_SYSTEM_ID_SINGLE_JOINT_ARM_MODEL</h3>
<p><IMG SRC="LINEAR_SYSTEM_ID_SINGLE_JOINT_ARM_MODEL_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;"></pre></p>
<p><IMG SRC="LINEAR_SYSTEM_ID_SINGLE_JOINT_ARM_MODEL_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_ID_SINGLE_JOINT_ARM_MODEL.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_LOOP" >TypeDef-LINEAR_SYSTEM_LOOP</h3>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Combines a controller, feedforward, and observer for controlling a mechanism with full state  feedback.<BR>
 <BR>
For everything in this file, "inputs" and "outputs" are defined from the perspective of the  plant. This means U is an input and Y is an output (because you give the plant U (powers) and it  gives you back a Y (sensor values). This is the opposite of what they mean from the perspective of the controller (U is an output because that's what goes to the motors and Y is an input because that's what comes back from the sensors).<BR>
 <BR>
This cluster contains:<BR>
   - Controller  --  Linear Quadratic Regulator data cluster<BR>
   - Feedforward  --  Linear Plant Inversion Feedforward data cluster<BR>
   - Observer  --  Kalman Filter data cluster<BR>
   - Next_R  --  Controllers next reference<BR>
   - Clamp Max  --  Maximum clamping values</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_LOOP.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_LOOP_CTRL_PARAMS" >TypeDef-LINEAR_SYSTEM_LOOP_CTRL_PARAMS</h3>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_CTRL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster containing control parameters needed for the Linear System Loop Execute function.<BR>
<BR>
Contains:<BR>
  -  Model Std Dev  --  double array (states)  --  Array of standard deviations for model states.<BR>
  -  Measure Std Dev  -- double array(outputs)  --  Array of standard devations for model outputs<BR>
  -  Control Tol  -- double array(states)  --  Array of standard deviations for controlled model states.<BR>
  -  Max Control Effort  -- double array(inputs)  --  Array of maximum values for inputs (classical control outputs) <BR>
<BR>
</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_CTRL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_LOOP_CTRL_PARAMS.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_LOOP_DCMOTOR_CTRL_PARAMS" >TypeDef-LINEAR_SYSTEM_LOOP_DCMOTOR_CTRL_PARAMS</h3>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_DCMOTOR_CTRL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster to contain control parameters for a DC motor linear system.   <BR>
<BR>
The DC Motor linear system is defined as:<BR>
  -  states: <BR>
      -  angular position (rad)<BR>
      -  angular velocity (rad/sec)<BR>
  -  inputs:<BR>
      -  motor voltage<BR>
  -  outputs: <BR>
      -  angular position (rad) <BR>
      -  angular velocity (rad/sec)<BR>
<BR>
Contains:<BR>
  -  Vel Model Std Dev  --  double  --  Standard deviation for modeled velocity (rad/sec)<BR>
  -  Pos Model Std Dev  --  double  --  Standard deviation for modeled position (rad)<BR>
  -  Vel Meas Std Dev  --  double  --  Standard deviation for measured velocity (rad/sec)<BR>
  -  Pos Meas Std Dev  --  double  --  Standard deviation for measured position (rad)<BR>
  -  Vel Ctrl Tol Std Dev  --  double  --  Control tolerance for velocity (rad/sec)<BR>
  -  Pos Ctrl Tol Std Dev  --  double  --  Control tolerance for position (rad)<BR>
  -  Max Ctrl Out  -- double  -- Maximum control output (Default: 12)  (volts)<BR>
</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_DCMOTOR_CTRL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_LOOP_DCMOTOR_CTRL_PARAMS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_LOOP_DIFF_DRV_CTRL_PARAMS" >TypeDef-LINEAR_SYSTEM_LOOP_DIFF_DRV_CTRL_PARAMS</h3>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_DIFF_DRV_CTRL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains the control parameters for a Diff Drive linear system.   <BR>
<BR>
The Diff Drive linear system is defined as:<BR>
  -  states<BR>
      -  left velocity (m/s)<BR>
      -  right velocity (m/s)<BR>
  -  inputs<BR>
      -  left voltage (volts)<BR>
      -  right voltage(volts)<BR>
  -  outputs<BR>
      -  left velocity (m/s)<BR>
      -  right velocity (m/s)<BR>
<BR>
Contains:<BR>
  -  Left Vel Model Std Dev  --  double  --  Standard deviation for modeled left velocity (meters/sec)<BR>
  -  Right Vel Model Std Dev  --  double  --  Standard deviation for modeled right velocity (meters/sec)<BR>
  -  Left Vel Meas Std Dev  --  double  --  Standard deviation for measured left velocity (meters/sec)<BR>
  -  Right Vel Meas Std Dev  --  double  --  Standard deviation for measured right velocity (meters/sec)<BR>
  -  Left Vel Ctrl Tol Std Dev  --  double  --   Control tolerance for left velocity (meters/sec)<BR>
  -  Right Vel Ctrl Tol Std Dev  --  double  --  Control tolerance for right velocity (meters/sec)<BR>
  -  Max Ctrl Out  -- double  -- Maximum control output (Default: 12)  (volts)<BR>
</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_DIFF_DRV_CTRL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_LOOP_DIFF_DRV_CTRL_PARAMS.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_LOOP_ELEVATOR_CTRL_PARAMS" >TypeDef-LINEAR_SYSTEM_LOOP_ELEVATOR_CTRL_PARAMS</h3>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_ELEVATOR_CTRL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains  the control parameters for an elevator linear system.   <BR>
<BR>
The Elevator linear system definition is:<BR>
  - States<BR>
      -  position (meters)<BR>
      -  velocity (meters/sec)<BR>
  - Inputs:<BR>
      -  motor voltage (volts)<BR>
  -  Outputs:<BR>
      -  position (meters)<BR>
<BR>
Contains:<BR>
  -  Pos Model Std Dev  --  double  --  Standard deviation for modeled position (meters)<BR>
  -  Vel Model Std Dev  --  double  --  Standard deviation for modeled velocity (meters/sec)<BR>
  -  Pos Meas Std Dev  --  double  --  Standard deviation for measured position (meters)<BR>
  -  Pos Ctrl Tol Std Dev  --  double  --  Control tolerance for position (meters)<BR>
  -  Max Ctrl Out  -- double  -- Maximum control output (Default: 12)  (volts)<BR>
</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_ELEVATOR_CTRL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_LOOP_ELEVATOR_CTRL_PARAMS.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_LOOP_FLYWHEEL_CTRL_PARAMS" >TypeDef-LINEAR_SYSTEM_LOOP_FLYWHEEL_CTRL_PARAMS</h3>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_FLYWHEEL_CTRL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains control parameters for a flywheel linear system.   <BR>
<BR>
The flywheel linear system definition is:<BR>
  - States<BR>
      -  angular velocity (Rad/Sec)<BR>
  - Inputs:<BR>
      -  motor voltage<BR>
  -  Outputs:<BR>
      -  angular velocity (rad/sec)<BR>
<BR>
Contains:<BR>
  -  Vel Model Std Dev  --  double  --  Standard deviation for modeled velocity (rad/sec)<BR>
  -  Vel Meas Std Dev  --  double  --  Standard deviation for measured velocity (rad/sec)<BR>
  -  Vel Ctrl Tol Std Dev  --  double  --  Control tolerance for velocity (rad/sec)<BR>
  -  Max Ctrl Out  -- double  -- Maximum control output (Default: 12)  (volts)<BR>
</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_FLYWHEEL_CTRL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_LOOP_FLYWHEEL_CTRL_PARAMS.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_LOOP_SNGJNTARM_CTRL_PARAMS" >TypeDef-LINEAR_SYSTEM_LOOP_SNGJNTARM_CTRL_PARAMS</h3>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_SNGJNTARM_CTRL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains the control parameters for a single jointed arm linear system.   <BR>
<BR>
The single jointed arm linear system definition is:<BR>
  - States<BR>
      -  angle position (Rad)<BR>
      -  velocity (Rad/Sec)<BR>
  - Inputs:<BR>
      -  motor voltage<BR>
  -  Outputs:<BR>
      -  angle position (rad)<BR>
<BR>
Contains:<BR>
  -  Ang Model Std Dev  -- double  --  Standard deviation for modeled angle (Rad)<BR>
  -  Vel Model Std Dev  --  double  --  Standard deviation for modeled velocity (rad/sec)<BR>
  -  Ang Measl Std Dev  -- double  --  Standard deviation for measured angle (Rad)<BR>
  -  Ang Ctrl Tol Std Dev  --  double  --  Control tolerance for angle (rad)<BR>
  -  Max Ctrl Out  -- double  -- Maximum control output (Default: 12)  (volts)<BR>
</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_LOOP_SNGJNTARM_CTRL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_LOOP_SNGJNTARM_CTRL_PARAMS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LINEAR_SYSTEM_SIM" >TypeDef-LINEAR_SYSTEM_SIM</h3>
<p><IMG SRC="LINEAR_SYSTEM_SIM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This cluster helps simulate linear systems. To use this class, implement a loop, perhaps in Periodic Tasks.  Then call "setInput" with the inputs to the system (usually voltage).   Then call "update" to update the simulation.   Then, set simulated sensor readings with the simulated positions in "getOutput".<BR>
<BR>
The cluster contains:<BR>
   - m_Plant  --  The plant that represents the linear system.<BR>
   - m_X  --  state variable<BR>
   - m_Y  --  output variable<BR>
   - m_U  --  input variable<BR>
   - MeasureStdDev  --  The standard deviations of measurements, used for adding noise to the measurements.<BR>
</pre></p>
<p><IMG SRC="LINEAR_SYSTEM_SIM_frontpanel.png"  ALT="Trajectory_Library.lvlib:LINEAR_SYSTEM_SIM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LTV_DIFF_DRIVE_CTRL" >TypeDef-LTV_DIFF_DRIVE_CTRL</h3>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">The linear time-varying differential drive controller has a similar form to the LQR, but the model used to compute the controller gain is the nonlinear model linearized around the drivetrain's current state. We precomputed gains for important places in our state-space, then interpolated between them with a LUT to save computational resources.Filters the provided voltages to limit a differential drive's linear and angular acceleration.<BR>
<BR>
The differential drive model can be created via the functions in LinearSystemId.<BR>
 <BR>
The data values are:<BR>
   - table -- Function Generator Matrix LUT (look up table) from drivetrain linear velocity to LQR gain<BR>
   - error<BR>
   - tolerance<BR>
   - trackWidth -- trackwidth (meters) <BR>
</pre></p>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_frontpanel.png"  ALT="Trajectory_Library.lvlib:LTV_DIFF_DRIVE_CTRL.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LTV_DIFF_DRIVE_CTRL_CONTROL_PARAMS" >TypeDef-LTV_DIFF_DRIVE_CTRL_CONTROL_PARAMS</h3>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_CONTROL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains packed control values for LTV Diff Drive Ctrl execute function<BR>
<BR>
Contains:<BR>
  -  Desired X Pos Ctrl Tol  --  double  --- Maximum desired X position control tolerance (meters, Default: 0.125)<BR>
  -  Desired Y Pos Ctrl Tol  --  double  --- Maximum desired y position control tolerance (meters, Default: 0.125)<BR>
  -  Desired Heading Ctrl Tol  --  double  --- Maximum desired heading control tolerance (meters, Default: 0.06)<BR>
  -  Desired Left Vel Ctrl Tol  --  double  --- Maximum desired left velocity control tolerance (meters, Default: 0.1)<BR>
  -  Desired Right Vel Ctrl Tol  --  double  --- Maximum desired right velocity control tolerance (meters, Default: 0.1)<BR>
  -  Max left vel ctrl effort V  -- double  -- Maximum left motor dmd control effort (volts, default 12.0)<BR>
  -  Max right vel ctrl effort V  -- double  -- Maximum right motor dmd control effort (volts, default 12.0)<BR>
<BR>
</pre></p>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_CONTROL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:LTV_DIFF_DRIVE_CTRL_CONTROL_PARAMS.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LTV_DIFF_DRIVE_CTRL_MODEL_PARAMS" >TypeDef-LTV_DIFF_DRIVE_CTRL_MODEL_PARAMS</h3>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_MODEL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains model, control, and tolerance values for LTV Diff Drive control execute function:<BR>
<BR>
Contains:<BR>
  -  Diff Drive Linear System  -- Linear system  -- Diff Drive linear system<BR>
  -  LTV Diff Drve Ctrl  --  cluster  --  Packed control parameters<BR>
  -  LTV Diff Drive Tol  --  cluster  --  Packed tolerance parameters<BR>
  -  Track Width  -- double  -- Track width (meters)<BR>
  -  dT Sec  -- double  -- Update time (Default 0.02)<BR>
<BR>
</pre></p>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_MODEL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:LTV_DIFF_DRIVE_CTRL_MODEL_PARAMS.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LTV_DIFF_DRIVE_CTRL_STATE_ENUM" >TypeDef-LTV_DIFF_DRIVE_CTRL_STATE_ENUM</h3>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_STATE_ENUM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">An enumerated varible containing names for the state indices of the LTV Differential Drive Train controller.</pre></p>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_STATE_ENUM_frontpanel.png"  ALT="Trajectory_Library.lvlib:LTV_DIFF_DRIVE_CTRL_STATE_ENUM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LTV_DIFF_DRIVE_CTRL_TOLERANCE" >TypeDef-LTV_DIFF_DRIVE_CTRL_TOLERANCE</h3>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_TOLERANCE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Contains tolerance values used to deterine on target  for LTV Diff Drive Ctrl execute function<BR>
<BR>
Contains:<BR>
  -  Max X tolerance  --  double  --- Maximum desired X position tolerance (meters, Default: 0.0625)<BR>
  -  Max Y tolerance  --  double  --- Maximum desired Y position tolerance (meters, Default 0.125)<BR>
  -  Max heading tolerance  --  double  --- Maximum desired heading tolerance (radians, Default 0.2)<BR>
  -  Max left vel tolerance  --  double  --- Maximum desired left velocity tolerance (meters/sec, Default 0.2)<BR>
  -  Max right vel tolerance  --  double  --- Maximum desired right velocity tolerance (meters/sec, Default: 0.2)<BR>
<BR>
</pre></p>
<p><IMG SRC="LTV_DIFF_DRIVE_CTRL_TOLERANCE_frontpanel.png"  ALT="Trajectory_Library.lvlib:LTV_DIFF_DRIVE_CTRL_TOLERANCE.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LTV_UNICYCLE_CONTROLLER" >TypeDef-LTV_UNICYCLE_CONTROLLER</h3>
<p><IMG SRC="LTV_UNICYCLE_CONTROLLER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">The linear time-varying unicycle controller has a similar form to the LQR, but the model used to compute the controller gain is the nonlinear model linearized around the drivetrain's current state.<BR>
<BR>
Holds the data an LTV Unicycle Controller.  The data cluster contains:<BR>
<BR>
   - PoseError<BR>
   - PoseTolerance<BR>
   - states<BR>
   - inputs<BR>
   - dT<BR>
   - Enabled<BR>
   - LQR K Table<BR>
<BR>
</pre></p>
<p><IMG SRC="LTV_UNICYCLE_CONTROLLER_frontpanel.png"  ALT="Trajectory_Library.lvlib:LTV_UNICYCLE_CONTROLLER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LTV_UNICYCLE_CONTROLLER_MODEL_PARAMS" >TypeDef-LTV_UNICYCLE_CONTROLLER_MODEL_PARAMS</h3>
<p><IMG SRC="LTV_UNICYCLE_CONTROLLER_MODEL_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Contains packed model and control values for LTV Unicycle Ctrl execute function<BR>
<BR>
Inputs:<BR>
  -  Max X Pos Meas Tol  --  double  --- Maximum desired X position measurement tolerance (meters, Default: 0.0625)<BR>
  -  Max Y Pos Meas Tol  --  double  --- Maximum desired y position measurement tolerance (meters, Default: 0.125)<BR>
  -  Max Heading Meas Tol  --  double  --- Maximum desired heading measurement tolerance (meters, Default: 0.2)<BR>
  -  Max angular ctrl effort V  -- double  -- Maximum angular control effort (rad/sec, default 2.0)<BR>
  -  Max linear vel ctrl effort V  -- double  -- Maximum linearcontrol effort (meters/sec, default 9.0)<BR>
<BR>
</pre></p>
<p><IMG SRC="LTV_UNICYCLE_CONTROLLER_MODEL_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:LTV_UNICYCLE_CONTROLLER_MODEL_PARAMS.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-LTV_UNICYCLE_CONTROLLER_TOLERANCE" >TypeDef-LTV_UNICYCLE_CONTROLLER_TOLERANCE</h3>
<p><IMG SRC="LTV_UNICYCLE_CONTROLLER_TOLERANCE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains on target tolerance values for LTV Unicycle Ctrl execute function<BR>
<BR>
Contains:<BR>
  -  Max X tolerance  --  double  --- Maximum desired X position tolerance (meters, Default: 0.0625)<BR>
  -  Max Y tolerance  --  double  --- Maximum desired Y position tolerance (meters, Default 0.125)<BR>
  -  Max heading tolerance  --  double  --- Maximum desired heading tolerance (radians, Default 0.2)<BR>
<BR>
</pre></p>
<p><IMG SRC="LTV_UNICYCLE_CONTROLLER_TOLERANCE_frontpanel.png"  ALT="Trajectory_Library.lvlib:LTV_UNICYCLE_CONTROLLER_TOLERANCE.CTL" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MECA_DRIVE_KINEMATICS" >TypeDef-MECA_DRIVE_KINEMATICS</h3>
<p><IMG SRC="MECA_DRIVE_KINEMATICS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Helper class that converts a chassis velocity (dx, dy, and dtheta components) into individual wheel speeds.<BR>
<BR>
The inverse kinematics (converting from a desired chassis velocity to individual wheel speeds) uses the relative locations of the wheels with respect to the center of rotation. The center of rotation for inverse kinematics is also variable. This means that you can set your set your center of rotation in a corner of the robot to perform special evasion manuevers.<BR>
 <BR>
Forward kinematics (converting an array of wheel speeds into the overall chassis motion) is performs the exact opposite of what inverse kinematics does. Since this is an overdetermined system (more equations than variables), we use a least-squares approximation.<BR>
<BR>
The inverse kinematics: [wheelSpeeds] = [wheelLocations][chassisSpeeds] We take the Moore-Penrose pseudoinverse of [wheelLocations] and then multiply by [wheelSpeeds] to get our chassis speeds.<BR>
 <BR>
Forward kinematics is also used for odometry -- determining the position of the robot on the field using encoders and a gyro.<BR>
</pre></p>
<p><IMG SRC="MECA_DRIVE_KINEMATICS_frontpanel.png"  ALT="Trajectory_Library.lvlib:MECA_DRIVE_KINEMATICS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MECA_DRIVE_ODOMETRY" >TypeDef-MECA_DRIVE_ODOMETRY</h3>
<p><IMG SRC="MECA_DRIVE_ODOMETRY_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Class for mecanum drive odometry. Odometry allows you to track the robot's position on the field over a course of a match using readings from your mecanum wheel encoders.<BR>
 <BR>
Teams can use odometry during the autonomous period for complex tasks like path following. Furthermore, odometry can be used for latency compensation when using computer-vision systems.<BR>
</pre></p>
<p><IMG SRC="MECA_DRIVE_ODOMETRY_frontpanel.png"  ALT="Trajectory_Library.lvlib:MECA_DRIVE_ODOMETRY.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MECA_DRIVE_POSE_EST" >TypeDef-MECA_DRIVE_POSE_EST</h3>
<p><IMG SRC="MECA_DRIVE_POSE_EST_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This data cluster and its associated function blocks wrap an UnscentedKalmanFilter Unscented Kalman Filter to fuse latency-compensated vision measurements with mecanum drive encoder velocity measurements. It will correct for noisy measurements and encoder drift. It is intended to be an easy but more accurate drop-in for MecanumDriveOdometry.<BR>
 <BR>
MecanumDrivePoseEstimator_update should be called every robot loop. If your loops are faster or slower than the default of 20 ms, then you should change the nominal delta time using the secondary constructor: MecanumDrivePoseEstimator_MecanumDrivePoseEstimator(Rotation2d, Pose2d MecanumDriveWheelPositions, MecanumDriveKinematics, Matrix, Matrix, Matrix, double).<BR>
 <BR>
MecanumDrivePoseEstimator_addVisionMeasurement can be called as infrequently as you want; if you never call it, then this data cluster will behave mostly like regular encoder odometry.<BR>
 <BR>
The state-space system used internally has the following states (x), inputs (u), and outputs (y):<BR>
 <BR>
        x = [x, y, theta, s_fl, s_fr, s_rl, s_rr]T <BR>
<BR>
        in the field coordinate system containing x position, y position, and heading, followed by<BR>
        the distance driven by the front left, front right, rear left, and rear right wheels.<BR>
 <BR>
        u = [v_x, v_y, omega, v_fl, v_fr, v_rl, v_rr]T <BR>
<BR>
        containing x velocity, y velocity, and angular rate in the field coordinate system, <BR>
        followed by the velocity of the front left, front right, rear left, and rear right wheels.<BR>
 <BR>
        y = [x, y, theta]T <BR>
<BR>
        from vision containing x position, y position, and heading; or <BR>
<BR>
        y = [theta, s_fl, s_fr, s_rl, s_rr]T<BR>
<BR>
        containing gyro heading, followed by the distance driven by the front left, front <BR>
        right, rear left, and rear right wheels.<BR>
</pre></p>
<p><IMG SRC="MECA_DRIVE_POSE_EST_frontpanel.png"  ALT="Trajectory_Library.lvlib:MECA_DRIVE_POSE_EST.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MECA_DRIVE_POSE_EST2" >TypeDef-MECA_DRIVE_POSE_EST2</h3>
<p><IMG SRC="MECA_DRIVE_POSE_EST2_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This set of functions wraps MecaDriveOdometry to fuse latency-compensated vision measurements with mecanum drive encoder distance measurements. It will correct for noisy measurements and encoder drift. It is intended to be a drop-in replacement MecaDriveOdometry.<BR>
 <BR>
MecaDrivePoseEst2_update should be called every robot loop.<BR>
 <BR>
MecaDrivePoseEst2_addVisionMeasurement can be called as infrequently as you want; if you never call it, then this class will behave mostly like regular encoder odometry.<BR>
<BR>
This data cluster contains:<BR>
  --  Meca_Drive_Odom  -- Meca_Drive__Odom  --  Odometry data cluster for this drive.<BR>
  --  M_Q -- <3,1> Matrix -- Matrix that holds standard deviations for the robot pose X, Y, theta (meters, meters, radians)<BR>
  --  M_Vision_K  --  <3,3> Matrix  -- Matrix that holds the gain matrix for closed loop continuous Kalman filter.<BR>
  --  Pose_Buffer -- TimeInterpBufferVariant  -- Holds last 1.5 seconds of position measurements.  <BR>
<BR>
</pre></p>
<p><IMG SRC="MECA_DRIVE_POSE_EST2_frontpanel.png"  ALT="Trajectory_Library.lvlib:MECA_DRIVE_POSE_EST2.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MECA_DRIVE_POSE_EST2_CONFIG" >TypeDef-MECA_DRIVE_POSE_EST2_CONFIG</h3>
<p><IMG SRC="MECA_DRIVE_POSE_EST2_CONFIG_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster containing data required by the MecaDrivePoseEst2_Execute function.  <BR>
<BR>
Contains:<BR>
  -  Front Left Wheel M  -- Translation2d  --  Locations front left wheel in relation to center of robot. (meters)<BR>
  -  Front Right Wheel M  -- Translation2d  --  Locations front right wheel in relation to center of robot. (meters)<BR>
  -  Rear Left Wheel M  -- Translation2d  --  Locations rear left wheel in relation to center of robot. (meters)<BR>
  -  Rear Right Wheel M  -- Translation2d  --  Locations rear right wheel in relation to center of robot. (meters)<BR>
  -  Odom X Std Dev M  -- double  --  Odometry X position standard deviation (Default: 0.02)  (meters)<BR>
  -  Odom Y Std Dev M  -- double  --  Odometry Y position standard deviation (Default: 0.02)  (meters)<BR>
  -  Odom Heading Std Dev M  -- double  --  Odometry Heading (gyro) position standard deviation (Default: 0.01)  (radians)<BR>
  -  Vision X Std Dev M  -- double  --  Vision X position standard deviation (Default: 0.1)  (meters)<BR>
  -  Vision Y Std Dev M  -- double  --  Vision Y position standard deviation (Default: 0.1)  (meters)<BR>
  -  Vision Heading Std Dev M  -- double  --  Vision Heading (gyro) position standard deviation (Default: 0.05)  (radians)<BR>
<BR>
</pre></p>
<p><IMG SRC="MECA_DRIVE_POSE_EST2_CONFIG_frontpanel.png"  ALT="Trajectory_Library.lvlib:MECA_DRIVE_POSE_EST2_CONFIG.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MECA_DRIVE_POSE_EST2_INTERP_RECORD" >TypeDef-MECA_DRIVE_POSE_EST2_INTERP_RECORD</h3>
<p><IMG SRC="MECA_DRIVE_POSE_EST2_INTERP_RECORD_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Differential Drive Pose Estimate 2 -- Interporatable Record<BR>
<BR>
Represents an odometry record. The record contains the inputs provided as well as the pose that was observed based on these inputs, as well as the previous record and its inputs.<BR>
<BR>
Contains:<BR>
  -  PoseMeters  --  Pose2d  -- The pose observed given the current sensor inputs and the previous pose.<BR>
  -  GyroAngle  -- Rotation2d  -- The current gyro angle.<BR>
  -  WheelPositions  --  MecaWheelPositions  --  The distances traveled by each wheel encoder.<BR>
<BR>
</pre></p>
<p><IMG SRC="MECA_DRIVE_POSE_EST2_INTERP_RECORD_frontpanel.png"  ALT="Trajectory_Library.lvlib:MECA_DRIVE_POSE_EST2_INTERP_RECORD.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MECA_WHEEL_POSITIONS" >TypeDef-MECA_WHEEL_POSITIONS</h3>
<p><IMG SRC="MECA_WHEEL_POSITIONS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents the mechanum drive wheel positions.  Cluster contains:<BR>
<BR>
   --  frontLeft  --  double -- Distance measured by the front left wheel. (Meters)<BR>
   --  frontRight  --  double -- Distance measured by the front right wheel. (Meters)<BR>
   --  rearLeft  --  double -- Distance measured by the rear left wheel. (Meters)<BR>
   --  rearRight  --  double -- Distance measured by the rear right wheel. (Meters)<BR>
</pre></p>
<p><IMG SRC="MECA_WHEEL_POSITIONS_frontpanel.png"  ALT="Trajectory_Library.lvlib:MECA_WHEEL_POSITIONS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MECA_WHEEL_SPEEDS" >TypeDef-MECA_WHEEL_SPEEDS</h3>
<p><IMG SRC="MECA_WHEEL_SPEEDS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents the mechanum drive wheel speeds</pre></p>
<p><IMG SRC="MECA_WHEEL_SPEEDS_frontpanel.png"  ALT="Trajectory_Library.lvlib:MECA_WHEEL_SPEEDS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MEDIAN_FILTER" >TypeDef-MEDIAN_FILTER</h3>
<p><IMG SRC="MEDIAN_FILTER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A cluster that implements a moving-window median filter. Useful for reducing measurement noise especially with processes that generate occasional, extreme outliers (such as values from vision processing, LIDAR, or ultrasonic sensors).<BR>
<BR>
This cluster contains:<BR>
   - m_valueBuffer  --  Circular buffer of past values<BR>
   - Size  --  Number of values allowed in buffer.   The number of samples in the moving window.<BR>
   - CurrentSize  -- Current number of values in buffer;<BR>
</pre></p>
<p><IMG SRC="MEDIAN_FILTER_frontpanel.png"  ALT="Trajectory_Library.lvlib:MEDIAN_FILTER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-MERWE_SCALED_SIGMA_PTS" >TypeDef-MERWE_SCALED_SIGMA_PTS</h3>
<p><IMG SRC="MERWE_SCALED_SIGMA_PTS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Generates sigma points and weights according to Van der Merwe's 2004 dissertation[1] for the UnscentedKalmanFilter function.<BR>
 <BR>
It parametrizes the sigma points using alpha, beta, kappa terms, and is the version seen in most publications. Unless you know better, this should be your default choice.<BR>
 <BR>
States is the dimensionality of the state. 2*States+1 weights will be generated.<BR>
 <BR>
[1] R. Van der Merwe "Sigma-Point Kalman Filters for Probabilitic Inference in Dynamic State-Space Models" (Doctoral dissertation)<BR>
<BR>
This cluster contains:<BR>
   - m_Wm  --  <BR>
   - m_Wc  --  <BR>
   - States  --  <BR>
   - Alpha  --  Determines the spread of the sigma points around the mean. Usually a small positive value (Default:  1.0e-3).<BR>
   - Kappa  --  Secondary scaling parameter usually set to 0 or 3 - States   (Default: 2)<BR>
<BR>
Note:<BR>
   - Beta is not included in the data, it is calculated or passed as a parameter.  (Default: 3 - States)<BR>
</pre></p>
<p><IMG SRC="MERWE_SCALED_SIGMA_PTS_frontpanel.png"  ALT="Trajectory_Library.lvlib:MERWE_SCALED_SIGMA_PTS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-OBSERVER_SNAPSHOT" >TypeDef-OBSERVER_SNAPSHOT</h3>
<p><IMG SRC="OBSERVER_SNAPSHOT_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster containing the data for a single snap shot of the Kalman Filter Latency Compensator.<BR>
<BR>
The cluster contains:<BR>
   - xHat<BR>
   - ErrorCoVariance<BR>
   - Inputs<BR>
   - LocalMeasurements<BR>
</pre></p>
<p><IMG SRC="OBSERVER_SNAPSHOT_frontpanel.png"  ALT="Trajectory_Library.lvlib:OBSERVER_SNAPSHOT.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-OBSERVER_SNAP_LIST_ITEM" >TypeDef-OBSERVER_SNAP_LIST_ITEM</h3>
<p><IMG SRC="OBSERVER_SNAP_LIST_ITEM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Observer List Item cluster contains a timestamped Observer Snapshot used by the Kalman Filter Latency Compensator.<BR>
</pre></p>
<p><IMG SRC="OBSERVER_SNAP_LIST_ITEM_frontpanel.png"  ALT="Trajectory_Library.lvlib:OBSERVER_SNAP_LIST_ITEM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-PARAM_STACK" >TypeDef-PARAM_STACK</h3>
<p><IMG SRC="PARAM_STACK_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Stack (Array) of data used by SplineParam_Spline_T0_T1.  </pre></p>
<p><IMG SRC="PARAM_STACK_frontpanel.png"  ALT="Trajectory_Library.lvlib:PARAM_STACK.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-PARAM_STACK_ITEM" >TypeDef-PARAM_STACK_ITEM</h3>
<p><IMG SRC="PARAM_STACK_ITEM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Stack data item used by SplineParam_Spline_T0_T1.  </pre></p>
<p><IMG SRC="PARAM_STACK_ITEM_frontpanel.png"  ALT="Trajectory_Library.lvlib:PARAM_STACK_ITEM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-PID_ADV_LIMITS" >TypeDef-PID_ADV_LIMITS</h3>
<p><IMG SRC="PID_ADV_LIMITS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster containing the limits for the Advanced PID controller.  <BR>
<BR>
This cluster contains:<BR>
   - Max_Input  --  If Continuous, this defines the maximum input value.  (Going above this wraps to the Min_Input.) <BR>
   - Min_Input  --  If Continuous, this defins the minimum input value.  (Going below this wraps to the Max_Input.)<BR>
   - Continuous  --  Boolean indicating that the measurement value wraps around (absoulte encoder or gyro)<BR>
   - Max_Output  --  Maximum allowed output (Used when applying integral windup protection.)<BR>
   - Min_Output  --  Minimum allowed output (Used when applying integral windup protection.)<BR>
<BR>
</pre></p>
<p><IMG SRC="PID_ADV_LIMITS_frontpanel.png"  ALT="Trajectory_Library.lvlib:PID_ADV_LIMITS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-PID_ADV_TUNING" >TypeDef-PID_ADV_TUNING</h3>
<p><IMG SRC="PID_ADV_TUNING_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This cluster contains the tuning parameters used by the Advanced PID controller.<BR>
<BR>
This cluster contains:<BR>
   - Kf  --   "Feedforward" control tuning constant<BR>
   - Kp  --  "Proportional" control tuning constant<BR>
   - Ki  --  "Integral" control tuning constant (dt is seconds)<BR>
   - Kd  --  "Derivative" control tuning constant (dt is seconds)<BR>
   - Max_Integral  --  Maximum allowed integral value (Default 1.0)<BR>
   - Min_Integral  --  Minimum allowed integral value (Default -1.0)<BR>
   - DerivativeFilter  --  Boolean indicating that derivative error value filtering is desired.<BR>
</pre></p>
<p><IMG SRC="PID_ADV_TUNING_frontpanel.png"  ALT="Trajectory_Library.lvlib:PID_ADV_TUNING.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-PID_CONTROLLER" >TypeDef-PID_CONTROLLER</h3>
<p><IMG SRC="PID_CONTROLLER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This implements a non-interacting PID where the Kp, Ki, Kd constants do not interact with each other (as is the case with a classical PID implementation).  Tuning schemes applicable to "classical" PIDs will need to consider the independence of the K values when applying new tuning.<BR>
<BR>
This cluster contains:<BR>
<BR>
   - Kp  --  "Proportional" control tuning constant<BR>
   - Ki  --  "Integral" control tuning constant (dt is seconds)<BR>
   - Kd  --  "Derivative" control tuning constant (dt is seconds)<BR>
   - Period  --  The period (in seconds) of the loop that calls the controller. (Default 0.020 seconds)<BR>
   - Max_Integral  --  Maximum allowed integral value (Default 1.0)<BR>
   - Min_Integral  --  Minimum allowed integral value (Default -1.0)<BR>
   - Continuous  --  Boolean indicating that the measurement value wraps around (absoulte encoder or gyro)<BR>
   - Max_Input  --  If Continuous, this defines the maximum input value.  (Going above this wraps to the Min_Input.) <BR>
   - Min_Input  --  If Continuous, this defins the minimum input value.  (Going below this wraps to the Max_Input.)<BR>
   - Measurement  --  Current measurement (Process Variable or PV)<BR>
   - Setpoint  --  Current setpoint (SP)<BR>
   - PositionError  --  The error at the time of the most recent call to calculate()<BR>
   - VelocityError  --  The current velocity error.  Used when calcuating on setpoint.<BR>
   - PrevError  --  The error at the time of the second-most-recent call to calculate() (used to compute velocity)<BR>
   - TotalError  --  The sum of the errors for use in the integral calc.  (Note: This sum is prior to applying Ki, causing an discontinuity in the output when performing online tuning.)<BR>
   - PositionTolerance  --  The position error that is considered at setpoint.  (Not used in control.)  (Default: 0.05)<BR>
   - VelocityTolerance  --  The velocity error that is considered at setpoint.  (Not used in control.)  (Default: Infinity)<BR>
<BR>
These values are used with the Advanced PID<BR>
   - Kf  --   "Feedforward" control tuning constant<BR>
   - DerivativeFilter  --  Boolean indicating that derivative error value filtering is desired.<BR>
   - Min_Output  --  Minimum allowed output (Used when applying integral windup protection.)<BR>
   - Max_output  --  Maximum allowed output (Used when applying integral windup protection.)<BR>
   - Prev_Deriv  --  Internal value.<BR>
   - Prev_Deriv2  --  Internal value.<BR>
   - Prev_F_P  --  Internal value<BR>
   - Prev_F_P2  --  Internal value.<BR>
   - AntiWindupActive  --  Boolean indicating that integral anti-windup protection is active (limiting the integral term)<BR>
</pre></p>
<p><IMG SRC="PID_CONTROLLER_frontpanel.png"  ALT="Trajectory_Library.lvlib:PID_CONTROLLER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-PID_ERROR_TOLERANCE" >TypeDef-PID_ERROR_TOLERANCE</h3>
<p><IMG SRC="PID_ERROR_TOLERANCE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This cluster contains the velocity and position tolerance for determining AtSetpoint.<BR>
<BR>
This cluster contains:<BR>
   - PositionTolerance  --  The position error that is considered at setpoint.  (Not used in control.)  (Default: 0.05)<BR>
   - VelocityTolerance  --  The velocity error that is considered at setpoint.  (Not used in control.)  (Default: Infinity)<BR>
<BR>
</pre></p>
<p><IMG SRC="PID_ERROR_TOLERANCE_frontpanel.png"  ALT="Trajectory_Library.lvlib:PID_ERROR_TOLERANCE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-PID_INPUT_LIMITS" >TypeDef-PID_INPUT_LIMITS</h3>
<p><IMG SRC="PID_INPUT_LIMITS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This cluster contains the input limit parameters for the "normal" PID controller<BR>
<BR>
This cluster contains:<BR>
   - Max_Input  --  If Continuous, this defines the maximum input value.  (Going above this wraps to the Min_Input.) <BR>
   - Min_Input  --  If Continuous, this defins the minimum input value.  (Going below this wraps to the Max_Input.)<BR>
   - Continuous  --  Boolean indicating that the measurement value wraps around (absoulte encoder or gyro)<BR>
</pre></p>
<p><IMG SRC="PID_INPUT_LIMITS_frontpanel.png"  ALT="Trajectory_Library.lvlib:PID_INPUT_LIMITS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-PID_TUNING" >TypeDef-PID_TUNING</h3>
<p><IMG SRC="PID_TUNING_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This cluster contains the tuning parameters for the "normal" PID controller.<BR>
<BR>
This cluster contains:<BR>
   - Kp  --  "Proportional" control tuning constant<BR>
   - Ki  --  "Integral" control tuning constant (dt is seconds)<BR>
   - Kd  --  "Derivative" control tuning constant (dt is seconds)<BR>
   - Max_Integral  --  Maximum allowed integral value (Default 1.0)<BR>
   - Min_Integral  --  Minimum allowed integral value (Default -1.0)<BR>
</pre></p>
<p><IMG SRC="PID_TUNING_frontpanel.png"  ALT="Trajectory_Library.lvlib:PID_TUNING.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-POSE2D" >TypeDef-POSE2D</h3>
<p><IMG SRC="POSE2D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a 2d pose containing translational and rotational elements.<BR>
</pre></p>
<p><IMG SRC="POSE2D_frontpanel.png"  ALT="Trajectory_Library.lvlib:POSE2D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-POSE3D" >TypeDef-POSE3D</h3>
<p><IMG SRC="POSE3D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a 3D pose containing translational and rotational elements. <BR>
</pre></p>
<p><IMG SRC="POSE3D_frontpanel.png"  ALT="Trajectory_Library.lvlib:POSE3D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-POSEwCURVATURE" >TypeDef-POSEwCURVATURE</h3>
<p><IMG SRC="POSEwCURVATURE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a pair of a pose and a curvature.<BR>
</pre></p>
<p><IMG SRC="POSEwCURVATURE_frontpanel.png"  ALT="Trajectory_Library.lvlib:POSEwCURVATURE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-PROFILED_PID_CONTROLLER" >TypeDef-PROFILED_PID_CONTROLLER</h3>
<p><IMG SRC="PROFILED_PID_CONTROLLER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Implements a PID control loop whose setpoint is constrained by a trapezoid profile. Users should call reset when they first start running the controller to avoid unwanted behavior.<BR>
<BR>
This cluster contains:<BR>
   - Controller  --  PID controller data cluster<BR>
   - Goal  --  TrapezoidProfile containing the goal.  (Velocity and Acceleration when setpoint is reached.)<BR>
   - Setpoint  --  TrapezoidProfile containing the setpoint.<BR>
   -Constraing  --  TrapezoidProfileConstraints containing the velocity and acceleration constraint.<BR>
</pre></p>
<p><IMG SRC="PROFILED_PID_CONTROLLER_frontpanel.png"  ALT="Trajectory_Library.lvlib:PROFILED_PID_CONTROLLER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-QUATERNION" >TypeDef-QUATERNION</h3>
<p><IMG SRC="QUATERNION_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Quaternion.  One use of this is  to represent a 3d Rotation.<BR>
</pre></p>
<p><IMG SRC="QUATERNION_frontpanel.png"  ALT="Trajectory_Library.lvlib:QUATERNION.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-RAMSETE" >TypeDef-RAMSETE</h3>
<p><IMG SRC="RAMSETE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Ramsete is a nonlinear time-varying feedback controller for unicycle models that drives the model to a desired pose along a two-dimensional trajectory. Why would we need a nonlinear control law in addition to the linear ones we have used so far like PID? If we use the original approach with PID controllers for left and right position and velocity states, the controllers only deal with the local pose. If the robot deviates from the path, there is no way for the controllers to correct and the robot may not reach the desired global pose. This is due to multiple endpoints existing for the robot which have the same encoder path arc lengths.<BR>
 <BR>
Instead of using wheel path arc lengths (which are in the robot's local coordinate frame), nonlinear controllers like pure pursuit and Ramsete use global pose. The controller uses this extra information to guide a linear reference tracker like the PID controllers back in by adjusting the references of the PID controllers.<BR>
<BR>
The paper "Control of Wheeled Mobile Robots: An Experimental Overview" describes a nonlinear controller for a wheeled vehicle with unicycle-like kinematics; a global pose consisting of x, y, and theta; and a desired pose consisting of x_d, y_d, and theta_d. We call it Ramsete because that's the acronym for the title of the book it came from in Italian ("Robotica Articolata e Mobile per i SErvizi e le TEcnologie").<BR>
<BR>
This cluster contains:<BR>
  --  B  --  Tuning parameter (b > 0 rad²/m²) for which larger values make convergence more aggressive like a proportional term.  (Default 2.0)<BR>
<BR>
  --  Zeta  --  Tuning parameter (0 /Rad < zeta < 1 /rad) for which larger values provide more damping in response. (Default 0.7)<BR>
<BR>
  -- Enabled  --  When TRUE the closed loop Ramsete controller is used.  When FALSE, input desired speeds are used directly (open loop).<BR>
<BR>
  --  Pose Tolerance  -- A Pose continaing the desired tolerance used to calculate On Target.<BR>
<BR>
  -- Pose Error  -- Current position and heading error.<BR>
<BR>
</pre></p>
<p><IMG SRC="RAMSETE_frontpanel.png"  ALT="Trajectory_Library.lvlib:RAMSETE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-RAMSETE_EXE_TUNING" >TypeDef-RAMSETE_EXE_TUNING</h3>
<p><IMG SRC="RAMSETE_EXE_TUNING_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Tuning parameters for the Ramsete EXE function.<BR>
<BR>
This cluster contains:<BR>
  --  Track Width M  --  The effective track width (Meters).  If the robot has a lot of "slippage", this value can be made greater than the actual physical track width to compensate.<BR>
<BR>
  --  Max Speed M/S  --  The maximum drive wheel speed (Meters/Second)<BR>
<BR>
  --  B  --  Tuning parameter (b > 0 rad²/m²) for which larger values make convergence more aggressive like a proportional term.  (Default 2.0)<BR>
<BR>
  --  Zeta  --  Tuning parameter (0 /Rad < zeta < 1 /rad) for which larger values provide more damping in response. (Default 0.7)<BR>
<BR>
<BR>
  --  X Tolerance  -- The X direction tolerance (Meters) used when calculating "on target"  (Default 0.051)<BR>
<BR>
  --  Y Tolerance  -- The Y direction tolerance (Meters) used when calculating "on target"  (Default 0.051)<BR>
<BR>
  --  Heading Tolerance  -- The rotational Heading tolerance (Radians) used when calculating "on target"  (Default 0.035)</pre></p>
<p><IMG SRC="RAMSETE_EXE_TUNING_frontpanel.png"  ALT="Trajectory_Library.lvlib:RAMSETE_EXE_TUNING.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-ROTATION2D" >TypeDef-ROTATION2D</h3>
<p><IMG SRC="ROTATION2D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A rotation in a 2d coordinate frame represented a point on the unit circle (cosine and sine).<BR>
<BR>
Default values are set for 0 degrees (0 radians).</pre></p>
<p><IMG SRC="ROTATION2D_frontpanel.png"  ALT="Trajectory_Library.lvlib:ROTATION2D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-ROTATION3D" >TypeDef-ROTATION3D</h3>
<p><IMG SRC="ROTATION3D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A rotation in a 3D coordinate</pre></p>
<p><IMG SRC="ROTATION3D_frontpanel.png"  ALT="Trajectory_Library.lvlib:ROTATION3D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SIMPLE_MOTOR_FF" >TypeDef-SIMPLE_MOTOR_FF</h3>
<p><IMG SRC="SIMPLE_MOTOR_FF_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A helper class that computes feedforward outputs for a simple permanent-magnet DC motor.<BR>
<BR>
Elements"<BR>
   - Ks - The static gain.<BR>
   - Kv - The velocity gain.<BR>
   - Ka - The acceleration gain.<BR>
   - KnInv  -- Optional 1/Kn constant used with the Advanced PID.  This helps to match the output units.<BR>
   </pre></p>
<p><IMG SRC="SIMPLE_MOTOR_FF_frontpanel.png"  ALT="Trajectory_Library.lvlib:SIMPLE_MOTOR_FF.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SIMPLE_MOTOR_FF_KA_TUNE_PARAMS" >TypeDef-SIMPLE_MOTOR_FF_KA_TUNE_PARAMS</h3>
<p><IMG SRC="SIMPLE_MOTOR_FF_KA_TUNE_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster data structure used to pack parameters that define the test to be performed when calculating the Simple Motor Feedforward Ka value.<BR>
<BR>
Elements:<BR>
  --  Max Sp --  Double -- The maximum value for the setpoint when ramping.<BR>
  --  Min Eval SP  --  Double  --  The lowest setpoint value to use when evaluating Ka<BR>
  --  Max Eval SP  --  Double  --  The highest setpoint value to use when evaluating Ka<BR>
  --  Ramp Rate  --  Double  --  The rate at which to ramp the setpoint (Units/Sec)<BR>
<BR>
</pre></p>
<p><IMG SRC="SIMPLE_MOTOR_FF_KA_TUNE_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:SIMPLE_MOTOR_FF_KA_TUNE_PARAMS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SINGLE_JOINT_ARM_SIM" >TypeDef-SINGLE_JOINT_ARM_SIM</h3>
<p><IMG SRC="SINGLE_JOINT_ARM_SIM_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a simulated single jointed arm mechanism. <BR>
<BR>
This cluster contains:<BR>
   - GearBox  --  DCMotor cluster, the gearbox for the arm.<BR>
   - Gearing  --  The gearing between the motors and the output.  (numbers greater than 1 represent reductions)<BR>
   - R_ArmLength  -- The length of the arm.  (Meters)<BR>
   - MinAngle  --  The minimum angle that the arm is capable of (Radians)<BR>
   - MaxAngle  --  The maximum angle that the arm is capable of.  (Radans)<BR>
   - ArmMass  --    The mass of the arm (Kilograms)<BR>
   - SimulateGravity  --  Boolean indicating whether the simulator should simulate gravity.<BR>
<BR>
</pre></p>
<p><IMG SRC="SINGLE_JOINT_ARM_SIM_frontpanel.png"  ALT="Trajectory_Library.lvlib:SINGLE_JOINT_ARM_SIM.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SINGLE_JOINT_ARM_SIM_SIMULATION_PARAMS" >TypeDef-SINGLE_JOINT_ARM_SIM_SIMULATION_PARAMS</h3>
<p><IMG SRC="SINGLE_JOINT_ARM_SIM_SIMULATION_PARAMS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster contains simulation parameters used by the Single Jointed Arm Simulation Execute routine.<BR>
<BR>
Contains:<BR>
  -  Min Angle  --  double  --  Minimum physical arm angle (radians)<BR>
  -  Max Angle  --  double  --  Maximum physical arm angle (radians)<BR>
  -  Pos Sim Std Dev  --  double  -- Standard deviation for the arm position (radians  Default: 0.09)<BR>
  - SimulateGravity  --  boolean  -- Simulate gravity (Default: True)<BR>
<BR>
</pre></p>
<p><IMG SRC="SINGLE_JOINT_ARM_SIM_SIMULATION_PARAMS_frontpanel.png"  ALT="Trajectory_Library.lvlib:SINGLE_JOINT_ARM_SIM_SIMULATION_PARAMS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SLEW_RATE_LIMITER" >TypeDef-SLEW_RATE_LIMITER</h3>
<p><IMG SRC="SLEW_RATE_LIMITER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Data cluster for a set of functions that limits the rate of change of an input value. Useful for implementing voltage, setpoint, and/or output ramps. A slew-rate limit is most appropriate when the quantity being controlled is a velocity or a voltage; when controlling a position, consider using a TrapezoidProfile}instead.<BR>
<BR>
Data:<BR>
   - RateLimit  -- Desired maximum rate THING/SEC<BR>
   - PrevValue  --  Previous value of THING<BR>
   - PrevTime  --  Time (Seconds) of last call when PrevValue was gathered.<BR>
<BR>
</pre></p>
<p><IMG SRC="SLEW_RATE_LIMITER_frontpanel.png"  ALT="Trajectory_Library.lvlib:SLEW_RATE_LIMITER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SPLINE" >TypeDef-SPLINE</h3>
<p><IMG SRC="SPLINE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a two-dimensional parametric spline that interpolates between two points.<BR>
</pre></p>
<p><IMG SRC="SPLINE_frontpanel.png"  ALT="Trajectory_Library.lvlib:SPLINE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SPLINE_CTRL_VECTOR" >TypeDef-SPLINE_CTRL_VECTOR</h3>
<p><IMG SRC="SPLINE_CTRL_VECTOR_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a control vector for a spline.<BR>
<BR>
Each element in each array represents the value of the derivative at the index. For example, the value of x[2] is the second derivative in the x dimension.<BR>
</pre></p>
<p><IMG SRC="SPLINE_CTRL_VECTOR_frontpanel.png"  ALT="Trajectory_Library.lvlib:SPLINE_CTRL_VECTOR.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SWERVE_DRIVE_KINEMATICS" >TypeDef-SWERVE_DRIVE_KINEMATICS</h3>
<p><IMG SRC="SWERVE_DRIVE_KINEMATICS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Helper class that converts a chassis velocity (dx, dy, and dtheta components) into individual module states (speed and angle).<BR>
 <BR>
The inverse kinematics (converting from a desired chassis velocity to individual module states) uses the relative locations of the modules with respect to the center of rotation. The center of rotation for inverse kinematics is also variable. This means that you can set your set your center of rotation in a corner of the robot to perform special evasion manuevers.<BR>
 <BR>
Forward kinematics (converting an array of module states into the overall chassis motion) is performs the exact opposite of what inverse kinematics does. Since this is an overdetermined system (more equations than variables), we use a least-squares approximation.<BR>
 <BR>
The inverse kinematics: [moduleStates] = [moduleLocations][chassisSpeeds] We take the Moore-Penrose pseudoinverse of [moduleLocations] and then multiply by [moduleStates] to get our chassis speeds.<BR>
 <BR>
Forward kinematics is also used for odometry -- determining the position of the robot on the field using encoders and a gyro.<BR>
</pre></p>
<p><IMG SRC="SWERVE_DRIVE_KINEMATICS_frontpanel.png"  ALT="Trajectory_Library.lvlib:SWERVE_DRIVE_KINEMATICS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SWERVE_DRIVE_MODULE_POSITION" >TypeDef-SWERVE_DRIVE_MODULE_POSITION</h3>
<p><IMG SRC="SWERVE_DRIVE_MODULE_POSITION_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents the position of one swerve module.   This cluster includes:<BR>
<BR>
   -   Distance measured by the wheel of the module. <BR>
   -  Angle of the module.   (Rotation2d)<BR>
</pre></p>
<p><IMG SRC="SWERVE_DRIVE_MODULE_POSITION_frontpanel.png"  ALT="Trajectory_Library.lvlib:SWERVE_DRIVE_MODULE_POSITION.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SWERVE_DRIVE_MODULE_STATE" >TypeDef-SWERVE_DRIVE_MODULE_STATE</h3>
<p><IMG SRC="SWERVE_DRIVE_MODULE_STATE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents the state of one swerve module.</pre></p>
<p><IMG SRC="SWERVE_DRIVE_MODULE_STATE_frontpanel.png"  ALT="Trajectory_Library.lvlib:SWERVE_DRIVE_MODULE_STATE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SWERVE_DRIVE_ODOMETRY" >TypeDef-SWERVE_DRIVE_ODOMETRY</h3>
<p><IMG SRC="SWERVE_DRIVE_ODOMETRY_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Class for swerve drive odometry. Odometry allows you to track the robot's position on the field over a course of a match using readings from your swerve drive encoders and swerve azimuth encoders.<BR>
 <BR>
Teams can use odometry during the autonomous period for complex tasks like path following. Furthermore, odometry can be used for latency compensationwhen using computer-vision systems.<BR>
</pre></p>
<p><IMG SRC="SWERVE_DRIVE_ODOMETRY_frontpanel.png"  ALT="Trajectory_Library.lvlib:SWERVE_DRIVE_ODOMETRY.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SWERVE_DRIVE_POSE_EST" >TypeDef-SWERVE_DRIVE_POSE_EST</h3>
<p><IMG SRC="SWERVE_DRIVE_POSE_EST_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This set of functions is deprecated.   Suggest using the new Swerve Drive Pose Est 2 instead.<BR>
<BR>
The functions that use this data cluster wrap an UnscentedKalmanFilter Unscented Kalman Filter to fuse latency-compensated vision measurements with swerve drive encoder velocity measurements. It will correct for noisy measurements and encoder drift. It is intended to be an easy but more accurate drop-in for SwerveDriveOdometry.<BR>
 <BR>
The generic arguments to this data cluster define the size of the state, input and output vectors used in the underlying UnscentedKalmanFilter Unscented Kalman Filter. Num States must be equal to the module count + 3. Num Inputs must be equal to the module count + 3.  Num Outputs must be equal to the module count + 1.<BR>
 <BR>
SwerveDrivePoseEstimator_update should be called every robot loop. If your loops are faster or slower than the default of 20 ms, then you should change the nominal delta time using the secondary constructor: SwerveDrivePoseEstimator_SwerveDrivePoseEstimator(Nat, Nat, Nat, Rotation2d, Pose2d, SwerveModulePosition[], SwerveDriveKinematics, Matrix, Matrix, Matrix, double).<BR>
 <BR>
SwerveDrivePoseEstimator_addVisionMeasurement can be called as infrequently as you want; if you never call it, then this class will behave mostly like regular encoder odometry.<BR>
 <BR>
The state-space system used internally has the following states (x), inputs (u), and outputs (y):<BR>
 <BR>
x = [x, y, theta, s_0, ..., s_n]t <BR>
<BR>
in the field coordinate system containing x position, y position, and heading, followed by the distance travelled by each wheel.<BR>
 <BR>
u = [v_x, v_y, omega, v_0, ... v_n]t  <BR>
<BR>
containing x velocity, y velocity, and angular rate in the field coordinate system, followed by the velocity measured at each wheel.<BR>
 <BR>
y = [x, y, theta]t <BR>
<BR>
 from vision containing x position, y position, and heading; or <BR>
<BR>
y = [theta, s_0, ..., s_n]t  <BR>
<BR>
containing gyro heading, followed by the distance travelled by each wheel.<BR>
</pre></p>
<p><IMG SRC="SWERVE_DRIVE_POSE_EST_frontpanel.png"  ALT="Trajectory_Library.lvlib:SWERVE_DRIVE_POSE_EST.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SWERVE_DRIVE_POSE_EST2" >TypeDef-SWERVE_DRIVE_POSE_EST2</h3>
<p><IMG SRC="SWERVE_DRIVE_POSE_EST2_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">This class wraps Swerve Drive Odometry to fuse latency-compensated vision measurements with swerve drive encoder measurements. It is intended to be a drop-in replacement for SwerveDrvOdom; in fact, if you never call SwerveDrvPoseEst_AddVisionMeasurement and only call  SwerveDrvPoseEst_Update then this will behave exactly the same as SwerveDrvOdom.<BR>
 <BR>
SwerveDrvPoseEst2_Update should be called every robot loop.<BR>
 <BR>
SwerveDrvPoseEst2_AddVisionMeasurement can be called as infrequently as you want.  If you never call it then this set of VI will behave exactly like regular encoder odometry.<BR>
<BR>
This data cluster contains:<BR>
  --  Swerve_Drive_Kinematics  -- Swerve_Drive_Kinematics  -- Kinematics data cluster that defines this drive.<BR>
  --  Swerve_Pose_Odom  -- Swerve_Drive__Odom  --  Odometry data cluster for this drive.<BR>
  --  M_Q -- <3,1> Matrix -- Matrix that holds standard deviations for the robot pose X, Y, theta (meters, meters, radians)<BR>
  --  M_Vision_K  --  <3,3> Matrix  -- Matrix that holds the gain matrix for closed loop continuous Kalman filter.<BR>
  --  Pose_Buffer -- TimeInterpBufferVariant  -- Holds last 1.5 seconds of position measurements.  <BR>
<BR>
</pre></p>
<p><IMG SRC="SWERVE_DRIVE_POSE_EST2_frontpanel.png"  ALT="Trajectory_Library.lvlib:SWERVE_DRIVE_POSE_EST2.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SWERVE_DRIVE_POSE_EST2_CONFIG" >TypeDef-SWERVE_DRIVE_POSE_EST2_CONFIG</h3>
<p><IMG SRC="SWERVE_DRIVE_POSE_EST2_CONFIG_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster containing data required by the SwerveDrivePoseEst2_Execute function.  <BR>
<BR>
Contains:<BR>
  -  Wheel Locations M  -- Translation2d array  --  Locations of module wheels in relation to center of robot. (meters)<BR>
  -  Odom X Std Dev M  -- double  --  Odometry X position standard deviation (Default: 0.02)  (meters)<BR>
  -  Odom Y Std Dev M  -- double  --  Odometry Y position standard deviation (Default: 0.02)  (meters)<BR>
  -  Odom Heading Std Dev M  -- double  --  Odometry Heading (gyro) position standard deviation (Default: 0.01)  (radians)<BR>
  -  Vision X Std Dev M  -- double  --  Vision X position standard deviation (Default: 0.1)  (meters)<BR>
  -  Vision Y Std Dev M  -- double  --  Vision Y position standard deviation (Default: 0.1)  (meters)<BR>
  -  Vision Heading Std Dev M  -- double  --  Vision Heading (gyro) position standard deviation (Default: 0.05)  (radians)<BR>
<BR>
</pre></p>
<p><IMG SRC="SWERVE_DRIVE_POSE_EST2_CONFIG_frontpanel.png"  ALT="Trajectory_Library.lvlib:SWERVE_DRIVE_POSE_EST2_CONFIG.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-SWERVE_DRIVE_POSE_EST2_INTERP_RECORD" >TypeDef-SWERVE_DRIVE_POSE_EST2_INTERP_RECORD</h3>
<p><IMG SRC="SWERVE_DRIVE_POSE_EST2_INTERP_RECORD_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Differential Drive Pose Estimate 2 -- Interporatable Record<BR>
</pre></p>
<p><IMG SRC="SWERVE_DRIVE_POSE_EST2_INTERP_RECORD_frontpanel.png"  ALT="Trajectory_Library.lvlib:SWERVE_DRIVE_POSE_EST2_INTERP_RECORD.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TIMER" >TypeDef-TIMER</h3>
<p><IMG SRC="TIMER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Data cluster holding values required by the TImer functions.  These functions allow timing between events without interrupting execution of other robot code.  <BR>
<BR>
Data:<BR>
   - StartTIme  --  Time the timer was started (Seconds).  This is not wall clock time, rather it uses a continuously counting value from some reference, generally the last time the computer was rebooted.<BR>
   - AccumulatedTime  --  Internal time variable<BR>
   - Running  -- If TRUE, the timer is running<BR>
   - Semaphore  -- Used to synchronize interactions between threads.</pre></p>
<p><IMG SRC="TIMER_frontpanel.png"  ALT="Trajectory_Library.lvlib:TIMER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TIME_INTERPOLATABLE_BOOLEAN" >TypeDef-TIME_INTERPOLATABLE_BOOLEAN</h3>
<p><IMG SRC="TIME_INTERPOLATABLE_BOOLEAN_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">The TimeInterpolatableBuffer provides an easy way to estimate past measurements. One application might be in conjunction with the DifferentialDrivePoseEstimator, where knowledge of the robot pose at the time when vision or other global measurement were recorded is necessary, or for recording the past angles of mechanisms as measured by encoders.<BR>
<BR>
The TIME_INTERPOLATABLE_BOOLEAN stores and returns boolean values.<BR>
</pre></p>
<p><IMG SRC="TIME_INTERPOLATABLE_BOOLEAN_frontpanel.png"  ALT="Trajectory_Library.lvlib:TIME_INTERPOLATABLE_BOOLEAN.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TIME_INTERPOLATABLE_DOUBLE" >TypeDef-TIME_INTERPOLATABLE_DOUBLE</h3>
<p><IMG SRC="TIME_INTERPOLATABLE_DOUBLE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">The TimeInterpolatableBuffer provides an easy way to estimate past measurements. One application might be in conjunction with the DifferentialDrivePoseEstimator, where knowledge of the robot pose at the time when vision or other global measurement were recorded is necessary, or for recording the past angles of mechanisms as measured by encoders.<BR>
<BR>
The TIME_INTERPOLATABLE_DOUBLE stores and returns DOUBLE values.<BR>
</pre></p>
<p><IMG SRC="TIME_INTERPOLATABLE_DOUBLE_frontpanel.png"  ALT="Trajectory_Library.lvlib:TIME_INTERPOLATABLE_DOUBLE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TIME_INTERPOLATABLE_POSE2D" >TypeDef-TIME_INTERPOLATABLE_POSE2D</h3>
<p><IMG SRC="TIME_INTERPOLATABLE_POSE2D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">The TimeInterpolatableBuffer provides an easy way to estimate past measurements. One application might be in conjunction with the DifferentialDrivePoseEstimator, where knowledge of the robot pose at the time when vision or other global measurement were recorded is necessary, or for recording the past angles of mechanisms as measured by encoders.<BR>
<BR>
The TIME_INTERPOLATABLE_POSE stores and returns POSE2D values.<BR>
</pre></p>
<p><IMG SRC="TIME_INTERPOLATABLE_POSE2D_frontpanel.png"  ALT="Trajectory_Library.lvlib:TIME_INTERPOLATABLE_POSE2D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TIME_INTERPOLATABLE_ROTATION2D" >TypeDef-TIME_INTERPOLATABLE_ROTATION2D</h3>
<p><IMG SRC="TIME_INTERPOLATABLE_ROTATION2D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">The TimeInterpolatableBuffer provides an easy way to estimate past measurements. One application might be in conjunction with the DifferentialDrivePoseEstimator, where knowledge of the robot pose at the time when vision or other global measurement were recorded is necessary, or for recording the past angles of mechanisms as measured by encoders.<BR>
<BR>
The TIME_INTERPOLATABLE_ROTATION stores and returns ROTATION2D values.<BR>
</pre></p>
<p><IMG SRC="TIME_INTERPOLATABLE_ROTATION2D_frontpanel.png"  ALT="Trajectory_Library.lvlib:TIME_INTERPOLATABLE_ROTATION2D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TIME_INTERPOLATABLE_VARIANT" >TypeDef-TIME_INTERPOLATABLE_VARIANT</h3>
<p><IMG SRC="TIME_INTERPOLATABLE_VARIANT_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">The TimeInterpolatableBuffer provides an easy way to estimate past measurements. One application might be in conjunction with the DifferentialDrivePoseEstimator, where knowledge of the robot pose at the time when vision or other global measurement were recorded is necessary, or for recording the past angles of mechanisms as measured by encoders.<BR>
<BR>
The TIME_INTERPOLATABLE_POSE stores and returns POSE2D values.<BR>
</pre></p>
<p><IMG SRC="TIME_INTERPOLATABLE_VARIANT_frontpanel.png"  ALT="Trajectory_Library.lvlib:TIME_INTERPOLATABLE_VARIANT.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJECTORY" >TypeDef-TRAJECTORY</h3>
<p><IMG SRC="TRAJECTORY_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a time-parameterized trajectory. The trajectory contains of various States that represent the pose, curvature, time elapsed, velocity, and acceleration at that point.</pre></p>
<p><IMG SRC="TRAJECTORY_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJECTORY.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONFIG" >TypeDef-TRAJ_CONFIG</h3>
<p><IMG SRC="TRAJ_CONFIG_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents the configuration for generating a trajectory. This class stores the start velocity, end velocity, max velocity, max acceleration, custom constraints, and the reversed flag.<BR>
 <BR>
The cluster must be constructed with a max velocity and max acceleration. The other parameters (start velocity, end velocity, constraints, reversed) have been defaulted to reasonable values (0, 0, {}, false). These values can be changed via the setXXX methods.<BR>
<BR>
It also contains the data for each contraint and a flag indicating if a particular constraint is active.  As new constraints are added, this cluster will be modified to conain them.</pre></p>
<p><IMG SRC="TRAJ_CONFIG_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONFIG.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_CENTRIPETAL_ACCEL" >TypeDef-TRAJ_CONSTRAINT_CENTRIPETAL_ACCEL</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_CENTRIPETAL_ACCEL_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A constraint on the maximum absolute centripetal acceleration allowed when traversing a trajectory. The centripetal acceleration of a robot is defined as the velocity squared divided by the radius of curvature.<BR>
<BR>
Effectively, limiting the maximum centripetal acceleration will cause the robot to slow down around tight turns, making it easier to track trajectories with sharp turns.<BR>
<BR>
Elements:<BR>
  - MaxCentripetalAccerl - The max centripetal acceleration. (meters/Sec^2)</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_CENTRIPETAL_ACCEL_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_CENTRIPETAL_ACCEL.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_DIIF_DRIVE_KINEMATICS" >TypeDef-TRAJ_CONSTRAINT_DIIF_DRIVE_KINEMATICS</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_DIIF_DRIVE_KINEMATICS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A class that enforces constraints on the differential drive kinematics.  This can be used to ensure that the trajectory is constructed so that the commanded velocities for both sides of the drivetrain stay below a certain limit.<BR>
<BR>
Elements:<BR>
  - Max Speed (Meters/Sec)<BR>
  - DiffDriveKinematics - data structure<BR>
</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_DIIF_DRIVE_KINEMATICS_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_DIIF_DRIVE_KINEMATICS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_DIIF_DRIVE_VOLTAGE" >TypeDef-TRAJ_CONSTRAINT_DIIF_DRIVE_VOLTAGE</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_DIIF_DRIVE_VOLTAGE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A class that enforces constraints on differential drive voltage expenditure based on the motor dynamics and the drive kinematics.  Ensures that the acceleration of any wheel of the robot while following the trajectory is never higher than what can be achieved with the given maximum voltage.<BR>
</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_DIIF_DRIVE_VOLTAGE_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_DIIF_DRIVE_VOLTAGE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_ELLIP_REGION" >TypeDef-TRAJ_CONSTRAINT_ELLIP_REGION</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_ELLIP_REGION_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A class that enforces a constraint when robot pose is withiin a defined elliptical region.  <BR>
<BR>
Elements:<BR>
  - Center - Translation defining the center of the ellipse.<BR>
   - Radii  --  Translation defining the size of the ellipse.<BR>
   - Constraint  -- Variant holding the constraint data cluster to enforce when inside the ellipse.<BR>
   - Constraint Type  --  Enum that indicates the type of the constraint to enforce.<BR>
</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_ELLIP_REGION_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_ELLIP_REGION.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_JERK" >TypeDef-TRAJ_CONSTRAINT_JERK</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_JERK_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A constraint on the maximum absolute centripetal acceleration allowed when traversing a trajectory. The centripetal acceleration of a robot is defined as the velocity squared divided by the radius of curvature.<BR>
<BR>
Effectively, limiting the maximum centripetal acceleration will cause the robot to slow down around tight turns, making it easier to track trajectories with sharp turns.<BR>
<BR>
Elements:<BR>
  - MaxCentripetalAccerl - The max centripetal acceleration. (meters/Sec^2)</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_JERK_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_JERK.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_MAX_VELOCITY" >TypeDef-TRAJ_CONSTRAINT_MAX_VELOCITY</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_MAX_VELOCITY_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A constraint on the maximum absolute velocity allowed when traversing a trajectory. <BR>
<BR>
Elements:<BR>
  - MaxVelocity - The max velocity. (meters/Sec)</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_MAX_VELOCITY_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_MAX_VELOCITY.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_MECA_DRIVE_KINEMATICS" >TypeDef-TRAJ_CONSTRAINT_MECA_DRIVE_KINEMATICS</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_MECA_DRIVE_KINEMATICS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A class that enforces constraints on the mecanum drive kinematics.  This can be used to ensure that the trajectory is constructed so that the commanded velocities all wheels of the drivetrain stay below a certain limit.<BR>
<BR>
Elements:<BR>
  - Max Speed (Meters/Sec)<BR>
  - MecanumDriveKinematics - data structure<BR>
</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_MECA_DRIVE_KINEMATICS_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_MECA_DRIVE_KINEMATICS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_MINMAX" >TypeDef-TRAJ_CONSTRAINT_MINMAX</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_MINMAX_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a minimum and maximum acceleration.   This is used exclusively by TrajectoryParam_timeParam and its internal routines.<BR>
<BR>
</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_MINMAX_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_MINMAX.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_RECT_REGION" >TypeDef-TRAJ_CONSTRAINT_RECT_REGION</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_RECT_REGION_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A class that enforces constraints when inside a rectangular area.  <BR>
<BR>
Elements:<BR>
  - BottomLeftPoint   --  Defines the rectangle.<BR>
  - TopRightPoint  -- Defines the rectangle.<BR>
   - Constraint  - Variant holding the constraint definition to use when inside the rectangle<BR>
   - Constraint Type  -- Enum containing the type of constraint.<BR>
  - DiffDriveKinematics - data structure<BR>
</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_RECT_REGION_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_RECT_REGION.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_CONSTRAINT_SWERVE_DRIVE_KINEMATICS" >TypeDef-TRAJ_CONSTRAINT_SWERVE_DRIVE_KINEMATICS</h3>
<p><IMG SRC="TRAJ_CONSTRAINT_SWERVE_DRIVE_KINEMATICS_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A class that enforces constraints on the swerve drive kinematics.  This can be used to ensure that the trajectory is constructed so that the commanded velocities drivetrain modules stay below a certain limit.<BR>
<BR>
Elements:<BR>
  -- Max Speed (meters/sec)<BR>
  -- Swerve Drive Kinematics data cluster<BR>
</pre></p>
<p><IMG SRC="TRAJ_CONSTRAINT_SWERVE_DRIVE_KINEMATICS_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_CONSTRAINT_SWERVE_DRIVE_KINEMATICS.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAJ_STATE" >TypeDef-TRAJ_STATE</h3>
<p><IMG SRC="TRAJ_STATE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a time-parameterized trajectory. The trajectory contains of various States that represent the pose, curvature, time elapsed, velocity, and acceleration at that point.<BR>
<BR>
Elements:<BR>
  - TimeSeconds - The time elapsed since the beginning of the trajectory. (seconds)<BR>
  - Velocity -  The speed at that point of the trajectory. (meters/sec)<BR>
  - Accleration - The acceleration at that point of the trajectory.  (meters/Sec^2)<BR>
  - POSE - The pose at that point of the trajectory.<BR>
  - Curvature - The curvature at that point of the trajectory. (Radians/Meter)</pre></p>
<p><IMG SRC="TRAJ_STATE_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAJ_STATE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRANSFORM2D" >TypeDef-TRANSFORM2D</h3>
<p><IMG SRC="TRANSFORM2D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a transformation for a Pose2d.<BR>
</pre></p>
<p><IMG SRC="TRANSFORM2D_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRANSFORM2D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRANSFORM3D" >TypeDef-TRANSFORM3D</h3>
<p><IMG SRC="TRANSFORM3D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a transformation for a Pose3d.<BR>
</pre></p>
<p><IMG SRC="TRANSFORM3D_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRANSFORM3D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRANSLATION2D" >TypeDef-TRANSLATION2D</h3>
<p><IMG SRC="TRANSLATION2D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a translation in 2d space.  This object can be used to represent a point or a vector.<BR>
<BR>
This assumes that you are using conventional mathematical axes.  When the robot is placed on the origin, facing toward the X direction, moving forward increases the X, whereas moving to the left increases the Y.<BR>
</pre></p>
<p><IMG SRC="TRANSLATION2D_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRANSLATION2D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRANSLATION3D" >TypeDef-TRANSLATION3D</h3>
<p><IMG SRC="TRANSLATION3D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Represents a translation in 3D space. This object can be used to represent a point or a vector.<BR>
<BR>
This assumes that you are using conventional mathematical axes. When the robot is at the origin facing in the positive X direction, forward is positive X, left is positive Y, and up is  positive Z.<BR>
</pre></p>
<p><IMG SRC="TRANSLATION3D_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRANSLATION3D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAPEZOID_PROFILE" >TypeDef-TRAPEZOID_PROFILE</h3>
<p><IMG SRC="TRAPEZOID_PROFILE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A trapezoid-shaped velocity profile.<BR>
 <BR>
While this class can be used for a profiled movement from start to finish, the intended usage is to filter a reference's dynamics based on trapezoidal velocity constraints. To compute the reference obeying this constraint, do the following.<BR>
 <BR>
Initialization:<BR>
       - Create a new trapezoid profile constraint and provide Max Velocity and Max Acceleration<BR>
       - Create an initial previous profile reference state and provide current position (distance, angle, or other) and Velocity<BR>
 <BR>
Run on update:<BR>
       - Create a new trapezoid profile given the constraints, unprofiled (current) reference  and the previous profile reference <BR>
       -  Calculate providing the time since last update, the result is a new previous profile reference<BR>
<BR>
where `unprofiledReference` is free to change between calls. Note that when the unprofiled reference is within the constraints, `calculate()` returns the unprofiled reference unchanged.<BR>
 <BR>
Otherwise, a timer can be started to provide monotonic values for `calculate()` and to determine when the profile has completed via `isFinished()`.<BR>
<BR>
   - EndAccel  --  <BR>
   - EndFullSpeed  --  <BR>
   - EndDeccel  --  <BR>
   - Direction  --  The direction of the profile, either 1 for forwards or -1 for inverted<BR>
   - Constraints  -- <BR>
   - Initial  --  <BR>
   - Goal  --  <BR>
<BR>
<BR>
</pre></p>
<p><IMG SRC="TRAPEZOID_PROFILE_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAPEZOID_PROFILE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAPEZOID_PROFILE_CONSTRAINT" >TypeDef-TRAPEZOID_PROFILE_CONSTRAINT</h3>
<p><IMG SRC="TRAPEZOID_PROFILE_CONSTRAINT_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Contains the constraints for a TrapezoidProfile.<BR>
    <BR>
     - maxVelocity  --  maximum velocity<BR>
     - maxAcceleration --  maximum acceleration<BR>
  <BR>
</pre></p>
<p><IMG SRC="TRAPEZOID_PROFILE_CONSTRAINT_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAPEZOID_PROFILE_CONSTRAINT.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TRAPEZOID_PROFILE_STATE" >TypeDef-TRAPEZOID_PROFILE_STATE</h3>
<p><IMG SRC="TRAPEZOID_PROFILE_STATE_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Contains the State, initial, current, or goal, for a Trapezoid Profile<BR>
<BR>
   - Position  --  Distance, or heading, or other parameter for which the profile is created.<BR>
   - Velocity  --  Velocity</pre></p>
<p><IMG SRC="TRAPEZOID_PROFILE_STATE_frontpanel.png"  ALT="Trajectory_Library.lvlib:TRAPEZOID_PROFILE_STATE.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TWIST2D" >TypeDef-TWIST2D</h3>
<p><IMG SRC="TWIST2D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A change in distance along arc since the last pose update. We can use ideas  from differential calculus to create new Pose2ds from a Twist2d and vise versa.<BR>
 <BR>
A Twist can be used to represent a difference between two poses.<BR>
</pre></p>
<p><IMG SRC="TWIST2D_frontpanel.png"  ALT="Trajectory_Library.lvlib:TWIST2D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-TWIST3D" >TypeDef-TWIST3D</h3>
<p><IMG SRC="TWIST3D_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A change in distance along a 3D arc since the last pose update. We can use ideas from differential calculus to create new Pose3ds from a Twist3d and vise versa.<BR>
 <BR>
A Twist can be used to represent a difference between two poses.</pre></p>
<p><IMG SRC="TWIST3D_frontpanel.png"  ALT="Trajectory_Library.lvlib:TWIST3D.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-UNSCENTED_KALMAN_CORRECT_FUNC_GROUP" >TypeDef-UNSCENTED_KALMAN_CORRECT_FUNC_GROUP</h3>
<p><IMG SRC="UNSCENTED_KALMAN_CORRECT_FUNC_GROUP_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Cluster containing the packed function group data to pass to the Correct subVI.<BR>
    <BR>
Data:<BR>
   -  H_Func  --  A vector-valued function of x and u that returns the measurement vector.<BR>
   - H_ExtraData  --  Variant containing extra data used by the H function.  The contents of the variant are specific to the H function.<BR>
   -  meanFuncY  --  A strict function reference that computes the mean of 2 States + 1 measurement vectors using a given set of weights.<BR>
   - meanFuncYExtra  --  Variant containing extra data used by the meanY function.  The contents of the variant are specific to the  function.<BR>
   -  residualFuncY  --  A strict function reference that computes the residual of two measurement vectors (i.e. it subtracts them.)<BR>
   - residualFuncYExtra  --  Variant containing extra data used by the residualY function.  The contents of the variant are specific to the  function.<BR>
   -  residualFuncX  --   A strict function reference that computes the residual of two state vectors (i.e. it subtracts them.)<BR>
   - residualFuncXExtra  --  Variant containing extra data used by the residualX function.  The contents of the variant are specific to the  function.<BR>
   -  addFuncX  --  A strict function reference that adds two state vectors.<BR>
   -  addFuncXExtra  --  Variant containing extra data used by the addY function.  The contents of the variant are specific to the  function.<BR>
</pre></p>
<p><IMG SRC="UNSCENTED_KALMAN_CORRECT_FUNC_GROUP_frontpanel.png"  ALT="Trajectory_Library.lvlib:UNSCENTED_KALMAN_CORRECT_FUNC_GROUP.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-UNSCENTED_KALMAN_FILTER" >TypeDef-UNSCENTED_KALMAN_FILTER</h3>
<p><IMG SRC="UNSCENTED_KALMAN_FILTER_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A Kalman filter combines predictions from a model and measurements to give an estimate of the true system state. This is useful because many states cannot be measured directly as a result of sensor noise, or because the state is "hidden".<BR>
 <BR>
Kalman filters use a K gain matrix to determine whether to trust the model or measurements more. Kalman filter theory uses statistics to compute an optimal K gain which minimizes the sum of squares error in the state estimate. This K gain is used to correct the state estimate by some amount of the difference between the actual measurements and the measurements predicted by the model.<BR>
<BR>
An unscented Kalman filter uses nonlinear state and measurement models. It propagates the error covariance using sigma points chosen to approximate the true probability distribution.<BR>
<BR>
The data contained in this cluster is:<BR>
    - xHat  -- <BR>
    - P  --  <BR>
    - SigmasF  --  <BR>
    - ContQ  --  <BR>
    - ContR  --  <BR>
    - MerweScaledSigmaPts  --  <BR>
    - States  --  Number of states<BR>
    - Outputs  --  Number of outputs<BR>
    - Inputs  --  Number of inputs<BR>
    -  dT_Sec  -- Time between calls (Seconds)<BR>
   -  addFuncX  --  A strict function reference that adds two state vectors.<BR>
   -  addFuncXExtra  --  A variant containing extra data for the addX function<BR>
   -  meanFuncX  --  A strict function reference that computes the mean of 2States + 1 state vectors using a given set of weights.<BR>
   -  meanFuncXExtra  --  A variant containing extra data for the meanX function<BR>
   -  meanFuncY  --  A strict function reference that computes the mean of 2 States + 1 measurement vectors using a given set of weights.<BR>
   -  meanFuncYExtra  --  A variant containing extra data for the meanY function<BR>
   -  residualFuncX  --   A strict function reference that computes the residual of two state vectors (i.e. it subtracts them.)<BR>
   -  residualFuncXExtra  --  A variant containing extra data for the residualX function<BR>
   -  residualFuncY  --  A strict function reference that computes the residual of two measurement vectors (i.e. it subtracts them.)<BR>
   -  residualFuncYExtra  --  A variant containing extra data for the residualY function<BR>
</pre></p>
<p><IMG SRC="UNSCENTED_KALMAN_FILTER_frontpanel.png"  ALT="Trajectory_Library.lvlib:UNSCENTED_KALMAN_FILTER.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-UNSCENTED_KALMAN_NEW_FUNC_GROUP" >TypeDef-UNSCENTED_KALMAN_NEW_FUNC_GROUP</h3>
<p><IMG SRC="UNSCENTED_KALMAN_NEW_FUNC_GROUP_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">A packed cluster to hold the call back function reference information:<BR>
<BR>
The cluster contains:<BR>
   -  meanFuncX  --  A strict function reference that computes the mean of 2States + 1 state vectors using a given set of weights.<BR>
   -  meanFuncXExtra  --  A variant containing extra data for the meanX function<BR>
   -  meanFuncY  --  A strict function reference that computes the mean of 2 States + 1 measurement vectors using a given set of weights.<BR>
   -  meanFuncYExtra  --  A variant containing extra data for the meanY function<BR>
   -  residualFuncX  --   A strict function reference that computes the residual of two state vectors (i.e. it subtracts them.)<BR>
   -  residualFuncXExtra  --  A variant containing extra data for the residualX function<BR>
   -  residualFuncY  --  A strict function reference that computes the residual of two measurement vectors (i.e. it subtracts them.)<BR>
   -  residualFuncYExtra  --  A variant containing extra data for the residualY function<BR>
   -  addFuncX  --  A strict function reference that adds two state vectors.<BR>
   -  addFuncXExtra  --  A variant containing extra data for the addX function<BR>
</pre></p>
<p><IMG SRC="UNSCENTED_KALMAN_NEW_FUNC_GROUP_frontpanel.png"  ALT="Trajectory_Library.lvlib:UNSCENTED_KALMAN_NEW_FUNC_GROUP.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-UTIL_PATHFINDER_CONFIG" >TypeDef-UTIL_PATHFINDER_CONFIG</h3>
<p><IMG SRC="UTIL_PATHFINDER_CONFIG_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Util data structure for printing of pathfinder path data.</pre></p>
<p><IMG SRC="UTIL_PATHFINDER_CONFIG_frontpanel.png"  ALT="Trajectory_Library.lvlib:UTIL_PATHFINDER_CONFIG.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-WEIGHTED_WAYPOINT" >TypeDef-WEIGHTED_WAYPOINT</h3>
<p><IMG SRC="WEIGHTED_WAYPOINT_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Spline / Trajectory way point with scalar weight. <BR>
<BR>
Data:<BR>
   -  Translation<BR>
         - X  --  X location (Generally meters)<BR>
         - Y  --  Y location (Generally meters)<BR>
   - Rotation  -- Heading (direction of travel)<BR>
   - Scalar  --  Weight value.  When using weights, the value must be greater than 0.  Larger values cause the spline to be straighter entering and leaving this waypoint.<BR>
</pre></p>
<p><IMG SRC="WEIGHTED_WAYPOINT_frontpanel.png"  ALT="Trajectory_Library.lvlib:WEIGHTED_WAYPOINT.ctl" ALIGN=BOTTOM></p><br>
<br>
<HR SIZE="6" WIDTH=" 100.000000%" COLOR="GREY">
<h3 id="TypeDef-X_Y_PAIR" >TypeDef-X_Y_PAIR</h3>
<p><IMG SRC="X_Y_PAIR_iconc.png"  ALIGN=BOTTOM></p>
<p><pre style="overflow-x: auto; white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; font-family: serif; font-size: 12pt;">Pair of X and Y value</pre></p>
<p><IMG SRC="X_Y_PAIR_frontpanel.png"  ALT="Trajectory_Library.lvlib:X_Y_PAIR.ctl" ALIGN=BOTTOM></p><br>
<br>
</BODY>
</HTML>